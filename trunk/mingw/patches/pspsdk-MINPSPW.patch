Index: pspsdk/src/samples/exceptions/main.cpp
===================================================================
--- pspsdk/src/samples/exceptions/main.cpp	(revision 0)
+++ pspsdk/src/samples/exceptions/main.cpp	(revision 0)
@@ -0,0 +1,51 @@
+#include <pspkernel.h>
+#include <pspdebug.h>
+#include <pspctrl.h>
+
+/* Define printf, just to make typing easier */
+#define printf  pspDebugScreenPrintf
+
+/* Define the module info section */
+PSP_MODULE_INFO("cppException", 0, 1, 1);
+
+/* Define the main thread's attribute value (optional) */
+PSP_MAIN_THREAD_ATTR(THREAD_ATTR_USER | THREAD_ATTR_VFPU);
+
+#include <exception>
+using namespace std;
+
+class myexception: public exception
+{
+	virtual const char* what() const throw()
+	{
+		return "My exception happened";
+	}
+} myex;
+
+int main (void)
+{
+	pspDebugScreenInit();
+	SceCtrlData pad;
+	
+	try
+	{
+		throw myex;
+	}
+	catch (exception& e)
+	{
+		printf("%s\n", e.what());
+	}
+	
+	printf("\nPress X to quit.\n");
+
+	for (;;)
+	{
+		sceCtrlReadBufferPositive(&pad, 1);
+		if (pad.Buttons & PSP_CTRL_CROSS)
+			break;
+	}
+	sceKernelExitGame();
+
+	return 0;
+}
+
Index: pspsdk/src/samples/exceptions/Makefile.sample
===================================================================
--- pspsdk/src/samples/exceptions/Makefile.sample	(revision 0)
+++ pspsdk/src/samples/exceptions/Makefile.sample	(revision 0)
@@ -0,0 +1,18 @@
+TARGET = CppException
+OBJS = main.o
+LIBS = -lstdc++
+
+INCDIR =
+CFLAGS = -G0 -Wall -O2
+CXXFLAGS = $(CFLAGS) -fno-rtti -fexceptions
+ASFLAGS = $(CFLAGS)
+
+LIBDIR =
+LDFLAGS =
+
+EXTRA_TARGETS = EBOOT.PBP
+PSP_EBOOT_TITLE = C++ Exception Sample
+
+PSPSDK=$(shell psp-config --pspsdk-path)
+include $(PSPSDK)/lib/build.mak
+
Index: pspsdk/src/fpu/pspfpu.h
===================================================================
--- pspsdk/src/fpu/pspfpu.h	(revision 2489)
+++ pspsdk/src/fpu/pspfpu.h	(working copy)
@@ -5,6 +5,7 @@
  *
  * pspfpu.h - Prototypes for the FPU library
  *
+ * Copyright (c) 2009 JetCube
  * Copyright (c) 2006 TyRaNiD (James F.) 
  *
  * $Id: pspfpu.h 1782 2006-02-04 12:57:05Z tyranid $
@@ -23,131 +24,131 @@
 #endif
 
 /** Enumeration for FPU rounding modes */
-enum FpuRoundMode
+enum PspFpuRoundMode
 {
 	/** Round to nearest representable value */
-	FPU_RN = 0,
+	PSP_FPU_RN = 0,
 	/** Round towards zero */
-	FPU_RZ = 1,
+	PSP_FPU_RZ = 1,
 	/** Round towards plus infinity */
-	FPU_RP = 2,
+	PSP_FPU_RP = 2,
 	/** Round towards minus infinity */ 
-	FPU_RM = 3,
+	PSP_FPU_RM = 3,
 };
 
 /** Mask value for rounding mode */
-#define FPU_RM_MASK 0x03 
+#define PSP_FPU_RM_MASK 0x03 
 
 /** Enumeration for FPU exceptions */
-enum FpuExceptions
+enum PspFpuExceptions
 {
 	/** Inexact operation exception */
-	FPU_EXCEPTION_INEXACT   = 0x01,
+	PSP_FPU_EXCEPTION_INEXACT   = 0x01,
 	/** Underflow exception */
-	FPU_EXCEPTION_UNDERFLOW = 0x02,
+	PSP_FPU_EXCEPTION_UNDERFLOW = 0x02,
 	/** Overflow exception */
-	FPU_EXCEPTION_OVERFLOW  = 0x04,
+	PSP_FPU_EXCEPTION_OVERFLOW  = 0x04,
 	/** Division by zero exception */
-	FPU_EXCEPTION_DIVBYZERO = 0x08,
+	PSP_FPU_EXCEPTION_DIVBYZERO = 0x08,
 	/** Invalid operation exception */
-	FPU_EXCEPTION_INVALIDOP = 0x10,
+	PSP_FPU_EXCEPTION_INVALIDOP = 0x10,
 	/** Unimplemented operation exception (only supported in the cause bits) */
-	FPU_EXCEPTION_UNIMPOP   = 0x20,
+	PSP_FPU_EXCEPTION_UNIMPOP   = 0x20,
 	/** All exceptions */
-	FPU_EXCEPTION_ALL       = 0x3F
+	PSP_FPU_EXCEPTION_ALL       = 0x3F
 };
 
 /** Bit position of the flag bits */
-#define FPU_FLAGS_POS   2
+#define PSP_FPU_FLAGS_POS   2
 /** Bit position of the enable bits */
-#define FPU_ENABLE_POS 7
+#define PSP_FPU_ENABLE_POS 7
 /** Bit position of the cause bits */
-#define FPU_CAUSE_POS  12
+#define PSP_FPU_CAUSE_POS  12
 /** Bit position of the cc0 bit */
-#define FPU_CC0_POS    23
+#define PSP_FPU_CC0_POS    23
 /** Bit position of the fs bit */
-#define FPU_FS_POS     24
+#define PSP_FPU_FS_POS     24
 /** Bit position of the cc1->7 bits */
-#define FPU_CC17_POS   25
+#define PSP_FPU_CC17_POS   25
 
-#define FPU_FLAGS_MASK  (0x1F << FPU_FLAGS_POS)
-#define FPU_ENABLE_MASK (0x1F << FPU_ENABLE_POS)
-#define FPU_CAUSE_MASK  (0x3F << FPU_CAUSE_POS)
-#define FPU_CC0_MASK    (1 << FPU_CC0_POS)
-#define FPU_FS_MASK     (1 << FPU_FS_POS)
-#define FPU_CC17_MASK   (0x7F << FPU_CC17_POS)
+#define PSP_FPU_FLAGS_MASK  (0x1F << PSP_FPU_FLAGS_POS)
+#define PSP_FPU_ENABLE_MASK (0x1F << PSP_FPU_ENABLE_POS)
+#define PSP_FPU_CAUSE_MASK  (0x3F << PSP_FPU_CAUSE_POS)
+#define PSP_FPU_CC0_MASK    (1 << PSP_FPU_CC0_POS)
+#define PSP_FPU_FS_MASK     (1 << PSP_FPU_FS_POS)
+#define PSP_FPU_CC17_MASK   (0x7F << PSP_FPU_CC17_POS)
 
 /**
  * Get the current value of the control/status register
  *
  * @return The value of the control/status register
  */
-uint32_t pspfpu_get_fcr31(void);
+uint32_t pspFpuGetFCR31(void);
 
 /**
  * Set the current value of the control/status register
  *
  * @param var - The value to set.
  */
-void pspfpu_set_fcr31(uint32_t var);
+void pspFpuSetFCR31(uint32_t var);
 
 /**
  * Set the current round mode
  *
- * @param mode - The rounding mode to set, one of ::FpuRoundMode
+ * @param mode - The rounding mode to set, one of ::PspFpuRoundMode
  */
-void pspfpu_set_roundmode(enum FpuRoundMode mode);
+void pspFpuSetRoundmode(enum PspFpuRoundMode mode);
 
 /**
  * Get the current round mode
  *
- * @return The round mode, one of ::FpuRoundMode
+ * @return The round mode, one of ::PspFpuRoundMode
  */
-enum FpuRoundMode pspfpu_get_roundmode(void);
+enum PspFpuRoundMode pspFpuGetRoundmode(void);
 
 /**
  * Get the exception flags (set when an exception occurs but
  * the actual exception bit is not enabled)
  *
- * @return Bitmask of the flags, zero or more of ::FpuExceptions
+ * @return Bitmask of the flags, zero or more of ::PspFpuExceptions
  */
-uint32_t pspfpu_get_flags(void);
+uint32_t pspFpuGetFlags(void);
 
 /** 
  * Clear the flags bits
  *
- * @param clear - Bitmask of the bits to clear, one or more of ::FpuExceptions
+ * @param clear - Bitmask of the bits to clear, one or more of ::PspFpuExceptions
  */
-void pspfpu_clear_flags(uint32_t clear);
+void pspFpuClearFlags(uint32_t clear);
 
 /**
  * Get the exception enable flags
  *
- * @return Bitmask of the flags, zero or more of ::FpuExceptions
+ * @return Bitmask of the flags, zero or more of ::PspFpuExceptions
  */
-uint32_t pspfpu_get_enable(void);
+uint32_t pspFpuGetEnable(void);
 
 /** 
  * Set the enable flags bits
  *
- * @param enable - Bitmask of exceptions to enable, zero or more of ::FpuExceptions
+ * @param enable - Bitmask of exceptions to enable, zero or more of ::PspFpuExceptions
  */
-void pspfpu_set_enable(uint32_t enable);
+void pspFpuSetEnable(uint32_t enable);
 
 /**
  * Get the cause bits (only useful if you installed your own exception handler)
  *
- * @return Bitmask of flags, zero or more of ::FpuExceptions
+ * @return Bitmask of flags, zero or more of ::PspFpuExceptions
  */
-uint32_t pspfpu_get_cause(void);
+uint32_t pspFpuGetCause(void);
 
 /**
  * Clear the cause bits
  *
- * @param clear - Bitmask of the bits to clear, one or more of ::FpuExceptions
+ * @param clear - Bitmask of the bits to clear, one or more of ::PspFpuExceptions
  *
  */
-void pspfpu_clear_cause(uint32_t clear);
+void pspFpuClearCause(uint32_t clear);
 
 /**
  * Get the current value of the FS bit (if FS is 0 then an exception occurs with
@@ -155,29 +156,244 @@
  *
  * @return The current state of the FS bit (0 or 1)
  */
-uint32_t pspfpu_get_fs(void);
+uint32_t pspFpuGetFS(void);
 
 /**
  * Set the FS bit
  *
  * @param fs - 0 or 1 to unset or set fs
  */
-void pspfpu_set_fs(uint32_t fs);
+void pspFpuSetFS(uint32_t fs);
 
 /**
  * Get the condition flags (8 bits)
  *
  * @return The current condition flags
  */
-uint32_t pspfpu_get_condbits(void);
+uint32_t pspFpuGetCondbits(void);
 
 /**
  * Clear the condition bits
  *
  * @param clear - Bitmask of the bits to clear
  */
-void pspfpu_clear_condbits(uint32_t clear);
+void pspFpuClearCondbits(uint32_t clear);
 
+/**
+ * returns absolute value
+ */
+float pspFpuAbs(float f);
+
+/**
+ * Round up 
+ */
+int   pspFpuCeil(float f);
+
+/**
+ * Truncate 
+ */
+int   pspFpuFloor(float f);
+
+/**
+ * select maximum value
+ */
+float pspFpuMax(float f1, float f2);
+
+/**
+ * select minimum value 
+ */
+float pspFpuMin(float f1, float f2);
+
+/**
+ * Sign reversal 
+ */
+float pspFpuNeg(float f);
+
+/**
+ * Round to nearest 
+ */
+int pspFpuRound(float f);
+
+/*
+ * Reciprocal of square root
+ */
+float pspFpuRsqrt(float f);
+
+/**
+ * Square root
+ */
+float pspFpuSqrt(float f);
+
+/**
+ * Round towards zero
+ */
+int pspFpuTrunc(float f);
+
+/**
+ * 
+ */
+float pspFpuFmod(float fs, float fd);
+
+/**
+ * 
+ */
+float pspFpuFrac(float f);
+
+/**
+ * 
+ */
+float pspFpuReinterpretFloat(uint32_t ui);
+
+/**
+ * 
+ */
+uint32_t pspFpuReinterpretUint(float f);
+
+/**
+ * 
+ */
+int pspFpuIsEqual(float f1, float f2);
+
+/**
+ * 
+ */
+float pspFpuSignFloat(float f);
+
+/**
+ *
+ */
+int pspFpuSignInt(float f);
+
+/**
+ * Positive zero
+ */
+float pspFpuPositiveZero(void);
+
+/**
+ * Negative zero
+ */
+float pspFpuNegativeZero(void);
+
+/**
+ * Test for zero value
+ */
+int pspFpuIsZero(float f);
+
+/**
+ * Test for positive zero
+ */
+int pspFpuIsPositiveZero(float f);
+
+/**
+ * Test for negative zero
+ */
+int pspFpuIsNegativeZero(float f);
+
+/**
+ * Test for denormalized number
+ */
+int pspFpuIsDenormal(float f);
+
+/**
+ * Test for zero or denormalized number
+ */
+int pspFpuIsZeroOrDenormal(float f);
+
+/**
+ * Positive infinity
+ */
+float pspFpuPositiveInf(void);
+
+/**
+ * Negative infinity
+ */
+float pspFpuNegativeInf(void);
+
+/**
+ * Test for infinity
+ */
+int pspFpuIsInf(float f);
+
+/** 
+ * NaN (positive SNaN)
+ */
+float pspFpuPositiveNaN(void);
+
+/**
+ * NaN (negative SNaN)
+ */
+float pspFpuNegativeNaN(void);
+
+/**
+ * Quiet NaN (positive QNaN)
+ */
+float pspFpuPositiveQNaN(void);
+
+/**
+ * Quiet NaN (positive QNaN)
+ */
+float pspFpuNegativeQNaN(void);
+
+/**
+ * Signaling NaN (positive SNaN)
+ */
+float pspFpuPositiveSNaN(unsigned int uiSignal);
+
+/**
+ * Signaling NaN (negative SNaN)
+ */
+float pspFpuNegativeSNaN(unsigned int uiSignal);
+
+/**
+ * Test for NaN
+ */
+int pspFpuIsNaN(float f);
+
+/**
+ * Test for infinity or NaN
+ */
+int pspFpuIsInfOrNaN(float f);
+
+/**
+ *
+ */
+float pspFpuNormalizePhase(float f);
+
+/**
+ * Sine
+ */
+float pspFpuSin(float x);
+
+/**
+ * Cosine
+ */
+float pspFpuCos(float x);
+
+/**
+ * Arc tangent
+ */
+float pspFpuAtan(float x);
+
+/**
+ * Natural Logarithm
+ */
+float pspFpuLog(float x);
+
+/**
+ * Exponential
+ */
+float pspFpuExp(float x);
+
+/**
+ * convert float to double
+ */
+double pspFpuFloatToDouble(float a);
+
+/**
+ * convert double to float
+ */
+float  pspFpuDoubleToFloat(double a);
+
 #ifdef __cplusplus
 }
 #endif
Index: pspsdk/src/fpu/pspfpu.c
===================================================================
--- pspsdk/src/fpu/pspfpu.c	(revision 2489)
+++ pspsdk/src/fpu/pspfpu.c	(working copy)
@@ -5,147 +5,891 @@
  *
  * pspfpu.h - PSP FPU library
  *
+ * Copyright (c) 2009 JetCube
  * Copyright (c) 2006 TyRaNiD (James F.) 
  *
  * $Id: pspfpu.c 1781 2006-02-04 12:53:40Z tyranid $
  */
 #include "pspfpu.h"
 
-uint32_t pspfpu_get_fcr31(void)
+#define PSP_MATH_PI		3.14159265358979323846		/* pi           */
+#define PSP_MATH_TWOPI	(PSP_MATH_PI * 2.0)			/* 2 * pi       */
+
+#define PSP_MATH_SQRT2	1.41421356237309504880		/* sqrt(2)      */
+
+#define COS_SIN_DIV 0.208
+
+static const float logPoly[] = {
+	 4194305.0 / (1024.0 * 1024.0 *  2.0), /* arround 2.0 */
+	 5590817.0 / (1024.0 * 1024.0 *  8.0), /* arround 2.0/3.0 */
+	13890687.0 / (1024.0 * 1024.0 * 32.0), /* arround 2.0/5.0 */
+};
+
+static const float triPoly[] = {
+	(float)(2.0*PSP_MATH_PI),
+	(float)(1.0),
+	(float)(-0xAAAA98/(1024.0*1024*64)),
+	(float)( 0x88801C/(1024.0*1024*1024)),
+	(float)(-0xCB9F27/(1024.0*1024*1024*64)),
+
+	(float)(-0xFFFFF9/(1024.0*1024*32)),
+	(float)( 0xAAA6FB/(1024.0*1024*256)),
+	(float)(-0xB3D431/(1024.0*1024*1024*8)),
+
+	(float)(-0xAAAAAA/(1024.0*1024*32)),
+	(float)( 0xCCCCCD/(1024.0*1024*64)),
+	(float)(-0x8F5C29/(1024.0*1024*64)),
+};
+
+uint32_t pspFpuGetFCR31(void)
 {
 	uint32_t ret;
 
 	asm(
-			"cfc1 %0, $31\n"
-			: "=r"(ret)
-	   );
+		"cfc1 %0, $31\n"
+		: "=r"(ret)
+	);
 
 	return ret;
 }
 
-void pspfpu_set_fcr31(uint32_t var)
+void pspFpuSetFCR31(uint32_t var)
 {
 	asm (
-			"ctc1 %0, $31\n"
-			: 
-			: "r"(var)
-		);
+		"ctc1 %0, $31\n"
+		: 
+		: "r"(var)
+	);
 }
 
-void pspfpu_set_roundmode(enum FpuRoundMode mode)
+void pspFpuSetRoundmode(enum PspFpuRoundMode mode)
 {
 	uint32_t fcr;
 
-	fcr = pspfpu_get_fcr31();
-	fcr &= ~FPU_RM_MASK;
-	fcr |= (mode & FPU_RM_MASK);
-	pspfpu_set_fcr31(fcr);
+	fcr = pspFpuGetFCR31();
+	fcr &= ~PSP_FPU_RM_MASK;
+	fcr |= (mode & PSP_FPU_RM_MASK);
+	pspFpuSetFCR31(fcr);
 }
 
-enum FpuRoundMode pspfpu_get_roundmode(void)
+enum PspFpuRoundMode pspFpuGetRoundmode(void)
 {
-	return pspfpu_get_fcr31() & FPU_RM_MASK;
+	return pspFpuGetFCR31() & PSP_FPU_RM_MASK;
 }
 
-uint32_t pspfpu_get_flags(void)
+uint32_t pspFpuGetFlags(void)
 {
 	uint32_t fcr;
 
-	fcr = pspfpu_get_fcr31();
+	fcr = pspFpuGetFCR31();
 	
-	return (fcr & FPU_FLAGS_MASK) >> FPU_FLAGS_POS;
+	return (fcr & PSP_FPU_FLAGS_MASK) >> PSP_FPU_FLAGS_POS;
 }
 
-void pspfpu_clear_flags(uint32_t clear)
+void pspFpuClearFlags(uint32_t clear)
 {
 	uint32_t fcr;
 
 	clear &= 0x1F;
-	fcr = pspfpu_get_fcr31();
-	fcr &= ~(clear << FPU_FLAGS_POS);
-	pspfpu_set_fcr31(fcr);
+	fcr = pspFpuGetFCR31();
+	fcr &= ~(clear << PSP_FPU_FLAGS_POS);
+	pspFpuSetFCR31(fcr);
 }
 
-uint32_t pspfpu_get_enable(void)
+uint32_t pspFpuGetEnable(void)
 {
 	uint32_t fcr;
 
-	fcr = pspfpu_get_fcr31();
+	fcr = pspFpuGetFCR31();
 	
-	return (fcr & FPU_ENABLE_MASK) >> FPU_ENABLE_POS;
+	return (fcr & PSP_FPU_ENABLE_MASK) >> PSP_FPU_ENABLE_POS;
 }
 
-void pspfpu_set_enable(uint32_t enable)
+void pspFpuSetEnable(uint32_t enable)
 {
 	uint32_t fcr;
 
 	enable &= 0x1F;
-	fcr = pspfpu_get_fcr31() & ~FPU_ENABLE_MASK;
-	fcr |= enable << FPU_ENABLE_POS;
-	pspfpu_set_fcr31(fcr);
+	fcr = pspFpuGetFCR31() & ~PSP_FPU_ENABLE_MASK;
+	fcr |= enable << PSP_FPU_ENABLE_POS;
+	pspFpuSetFCR31(fcr);
 }
 
-uint32_t pspfpu_get_cause(void)
+uint32_t pspFpuGetCause(void)
 {
 	uint32_t fcr;
 
-	fcr = pspfpu_get_fcr31();
+	fcr = pspFpuGetFCR31();
 	
-	return (fcr & FPU_CAUSE_MASK) >> FPU_CAUSE_POS;
+	return (fcr & PSP_FPU_CAUSE_MASK) >> PSP_FPU_CAUSE_POS;
 }
 
-void pspfpu_clear_cause(uint32_t clear)
+void pspFpuClearCause(uint32_t clear)
 {
 	uint32_t fcr;
 
 	clear &= 0x3F;
-	fcr = pspfpu_get_fcr31();
-	fcr &= ~(clear << FPU_CAUSE_POS);
-	pspfpu_set_fcr31(fcr);
+	fcr = pspFpuGetFCR31();
+	fcr &= ~(clear << PSP_FPU_CAUSE_POS);
+	pspFpuSetFCR31(fcr);
 }
 
-uint32_t pspfpu_get_fs(void)
+uint32_t pspFpuGetFS(void)
 {
 	uint32_t fcr;
 
-	fcr = pspfpu_get_fcr31();
+	fcr = pspFpuGetFCR31();
 	
-	return (fcr & FPU_FS_MASK) >> FPU_FS_POS;
+	return (fcr & PSP_FPU_FS_MASK) >> PSP_FPU_FS_POS;
 }
 
-void pspfpu_set_fs(uint32_t fs)
+void pspFpuSetFS(uint32_t fs)
 {
 	uint32_t fcr;
 
-	fcr = pspfpu_get_fcr31();
-	fcr &= ~FPU_FS_MASK;
+	fcr = pspFpuGetFCR31();
+	fcr &= ~PSP_FPU_FS_MASK;
 
-	fcr |= ((fs & 1) << FPU_FS_POS);
+	fcr |= ((fs & 1) << PSP_FPU_FS_POS);
 
-	pspfpu_set_fcr31(fcr);
+	pspFpuSetFCR31(fcr);
 }
 
-uint32_t pspfpu_get_condbits(void)
+uint32_t pspFpuGetCondbits(void)
 {
 	uint32_t fcr;
 	uint32_t cond;
 
-	fcr = pspfpu_get_fcr31();
-	cond = (fcr & FPU_CC0_MASK) >> FPU_CC0_POS;
-	cond |= (fcr & FPU_CC17_MASK) >> (FPU_CC17_POS-1);
+	fcr = pspFpuGetFCR31();
+	cond = (fcr & PSP_FPU_CC0_MASK) >> PSP_FPU_CC0_POS;
+	cond |= (fcr & PSP_FPU_CC17_MASK) >> (PSP_FPU_CC17_POS-1);
 
 	return cond;
 }
 
-void pspfpu_clear_condbits(uint32_t clear)
+void pspFpuClearCondbits(uint32_t clear)
 {
 	uint32_t fcr;
 
 	clear &= 0xFF;
 
-	fcr = pspfpu_get_fcr31();
-	fcr &= ~((clear & 1) << FPU_CC0_POS);
-	fcr &= ~((clear & 0xFE) << (FPU_CC17_POS-1));
+	fcr = pspFpuGetFCR31();
+	fcr &= ~((clear & 1) << PSP_FPU_CC0_POS);
+	fcr &= ~((clear & 0xFE) << (PSP_FPU_CC17_POS-1));
 
-	pspfpu_set_fcr31(fcr);
+	pspFpuSetFCR31(fcr);
 }
+
+float pspFpuAbs(float fs)
+{
+	register float fd;
+	asm (
+		"abs.s %0, %1\n"
+		: "=f"(fd)
+		: "f"(fs)
+	);
+	return (fd);
+}
+
+int pspFpuCeil(float fs)
+{
+	return (__builtin_allegrex_ceil_w_s(fs));
+}
+
+int pspFpuFloor(float fs)
+{
+	return (__builtin_allegrex_floor_w_s(fs));
+}
+
+float pspFpuMax(float fs1, float fs2)
+{
+	register float fd;
+	fd = (fs1 > fs2) ? fs1 : fs2;
+	return (fd);
+}
+
+float pspFpuMin(float fs1, float fs2)
+{
+	register float fd;
+	fd = (fs1 < fs2) ? fs1 : fs2;
+	return (fd);
+}
+
+float pspFpuNeg(float fs)
+{
+	register float fd;
+	asm (
+		"neg.s %0, %1\n"
+		: "=f"(fd)
+		: "f"(fs)
+	);
+	return (fd);
+}
+
+int pspFpuRound(float fs)
+{
+	return (__builtin_allegrex_round_w_s(fs));
+}
+
+float pspFpuRsqrt(float fs)
+{
+	return (1.0f / __builtin_allegrex_sqrt_s(fs));
+}
+
+float pspFpuSqrt(float fs)
+{
+	return (__builtin_allegrex_sqrt_s(fs));
+}
+
+int pspFpuTrunc(float fs)
+{
+	return (__builtin_allegrex_trunc_w_s(fs));
+}
+
+float pspFpuFmod(float fs, float fd)
+{
+	float v;
+	asm (
+		".set push\n"
+		".set noreorder\n"
+		"div.s %0, %1, %2\n"		// v = fs / fd
+		"trunc.w.s %0, %0\n"		// v = trunc(v)
+		"cvt.s.w %0, %0\n"		// v = (float)v = (float)trunc(v)
+		"mul.s %0, %0, %2\n"		// v = v * fd
+		"sub.s %0, %1, %0\n"		// v = fs - v*fd = fs - trunc(fs / fd)*fd
+		".set pop\n"
+		: "=&f"(v)
+		: "f"(fs), "f"(fd)
+	);
+	return (v);
+}
+
+float pspFpuFrac(float fs)
+{
+	float v;
+	asm (
+		".set push\n"
+		".set noreorder\n"
+		"trunc.w.s %0, %1\n"		// v = trunc(fs)
+		"cvt.s.w %0, %0\n"		// v = (float)v = (float)trunc(fs)
+		"sub.s %0, %1, %0\n"		// v = fs - v
+		".set pop\n"
+		: "=&f"(v)
+		: "f"(fs)
+	);
+	return (v);
+}
+
+float pspFpuReinterpretFloat(uint32_t ui)
+{
+	float v;
+	asm (
+		"mtc1 %1, %0\n"
+		: "=f"(v)
+		: "r"(ui)
+	);
+	return (v);
+}
+
+uint32_t pspFpuReinterpretUint(float fs)
+{
+	unsigned int v;
+	asm (
+		"mfc1 %0, %1\n"
+		: "=r"(v)
+		: "f"(fs)
+	);
+	return (v);
+}
+
+int   pspFpuIsEqual(float fs1, float fs2)
+{
+	int v;
+	asm (
+		".set push\n"
+		".set noreorder\n"
+		"c.eq.s %2, %1\n"		// compare fs1 to fs2
+		"move %0, $0\n"			// v = 0
+		"bc1tl 0f\n"			// if (fs1==fs2) goto 0f
+		"addiu %0, $0, 1\n"		// if (fs1==fs2) v = 1
+		"0:\n"
+		".set pop\n"
+		: "=r"(v)
+		: "f"(fs1), "f"(fs2)
+	);
+	return (v);
+}
+
+float pspFpuSignFloat(float fs)
+{
+	float fv;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 $8, %1\n"			// t0 = fs
+		"lui $10, 0x3F80\n"		// t2 = 0x3F800000(1.0f)
+		"srl $9, $8, 23\n"		// t1 = t0>>23
+		"srl $8, $8, 31\n"		// t0 = t0>>31
+		"andi $9, $9, 0x00FF\n"		// t1 = t1 & 0x00FF
+		"sll $8, $8, 31\n"		// t0 = t0<<31 = (fs>=0) ? 0 : 0x80000000
+		"movz $10, $0, $9\n"		// t2 = (t1==0) ? 0 : t2
+		"or $10, $10, $8\n"		// t2 = t2 | t0
+		"mtc1 $10, %0\n"		// fv = t2
+		".set pop\n"		
+		: "=f"(fv)
+		: "f"(fs)
+		: "$8", "$9", "$10"
+	);
+	return (fv);
+}
+
+int pspFpuSignInt(float fs)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 %0, %1\n"			// v = fs
+		"lui $8, 0x7F80\n"		// t0 = 0x7F800000(binary representaion 1.0 * 2^(255-127))
+		"and $8, $8, %0\n"		// t0 = at & v
+		"sra %0, %0, 30\n"		// v  = fs>>30 = (fs>=0) ? 0or1 : -1or-2
+		"or %0, %0, 1\n"		// v  = v | 1  = (fs>=0) ? 1 : -1
+		"movz %0, $0, $8\n"		// v  = (t0==0) ? 0 : v
+		".set pop\n"		
+		: "=r"(v)
+		: "f"(fs)
+		: "$8"
+	);
+	return (v);
+}
+
+float pspFpuPositiveZero(void)
+{
+	float v;
+	asm (
+		"mtc1 $0, %0\n"			// v = 0.0f
+		: "=f"(v)
+	);
+	return (v);
+}
+
+float pspFpuNegativeZero(void)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui $8, 0x8000\n"		// t0 = 0x80000000
+		"mtc1 $8, %0\n"			// v = -0.0f
+		".set pop\n"		
+		: "=f"(v)
+		:
+		: "$8"
+	);
+	return (v);
+}
+
+int pspFpuIsZero(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 $8, %1\n"			// t0 = f
+		"sra %0, $8, 30\n"		// v  = t0>>30
+		"sll $8, $8, 1\n"		// t0 = t0<<1
+		"ori %0, %0, 0x0001\n"		// v  = v | 1 = (f>=0) ? +1 : -1
+		"movn %0, $0, $8\n"		// v  = (t0!=0) ? 0 : v
+		".set pop\n"		
+		: "=r"(v)
+		: "f"(f)
+		: "$8"
+	);
+	return (v);
+}
+
+int pspFpuIsPositiveZero(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 %0, %1\n"			// v  = f
+		"sltiu %0, %0, 1\n"		// v  = (v < 1)
+		".set pop\n"
+		: "=r"(v)
+		: "f"(f)
+	);
+	return (v);
+}
+
+int pspFpuIsNegativeZero(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 %0, %1\n"			// v  = f
+		"lui $8, 0x8000\n"		// t0 = 0x80000000
+		"xor %0, %0, $8\n"		// v  = v ^ t0
+		"sltiu %0, %0, 1\n"		// v  = (v < 1)
+		".set pop\n"
+		: "=r"(v)
+		: "f"(f)
+		: "$8"
+	);
+	return (v);
+}
+
+int pspFpuIsDenormal(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 $8, %1\n"			// t0 = f
+		"lui $9, 0x7F80\n"		// t1 = 0x7F800000
+		"or %0, $8, $9\n"		// v  = t0 | t1 = t0 | 0x7F800000
+		"and $9, $8, $9\n"		// t1 = t0 & t1 = t0 & 0x7F800000
+		"sra %0, %0, 30\n"		// v  = v>>30   = (t0>=0) ? +1 : -1
+		"sll $8, $8, 9\n"		// t0 = t0<<9
+		"movn %0, $0, $9\n"		// v  = (t1!=0) ? 0 : v		if (exp!=0) is not denormal number
+		"movz %0, $0, $8\n"		// v  = (t0==0) ? 0 : v		if (frac==0) is not decnormal number
+		".set pop\n"
+		: "=r"(v)
+		: "f"(f)
+		: "$8", "$9"
+	);
+	return (v);
+}
+
+int   pspFpuIsZeroOrDenormal(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 $8, %1\n"			// t0 = f
+		"lui $9, 0x7F80\n"		// t1 = 0x7F800000
+		"or %0, $8, $9\n"		// v  = t0 | t1 = t0 | 0x7F800000
+		"and $9, $8, $9\n"		// t1 = t0 & t1 = t0 & 0x7F800000
+		"sra %0, %0, 30\n"		// v  = v>>30   = (t0>=0) ? +1 : -1
+		"movn %0, $0, $9\n"		// v  = (t1!=0) ? 0 : v		if (exp!=0) is not denormal number
+		".set pop\n"
+		: "=r"(v)
+		: "f"(f)
+		: "$8", "$9"
+	);
+	return (v);
+}
+
+float pspFpuPositiveInf(void)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui $8, 0x7F80\n"		// t0 = 0x7F800000
+		"mtc1 $8, %0\n"			// v  = t0 = +Infinity
+		".set pop\n"		
+		: "=f"(v)
+		:
+		: "$8"
+	);
+	return (v);
+}
+
+float pspFpuNegativeInf(void)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui $8, 0xFF80\n"		// t0 = 0xFF800000
+		"mtc1 $8, %0\n"			// v  = t0 = -Infinity
+		".set pop\n"		
+		: "=f"(v)
+	);
+	return (v);
+}
+
+int pspFpuIsInf(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 $8, %1\n"			// t0 = f
+		"sll $9, $8, 1\n"		// t1 = t0<<1
+		"sra %0, $8, 30\n"		// v  = t0>>30
+		"srl $9, $9, 24\n"		// t1 = t1>>24
+		"sll $8, $8, 9\n"		// t0 = t0<<9
+		"ori %0, %0, 0x0001\n"		// v  = v | 0x00000001 = (f>=0) ? +1 : -1
+		"sltiu $9, $9, 0x00FF\n"	// t1 = (t1<0xFF)
+		"movn %0, $0, $8\n"		// v  = (t0!=0) ? 0 : v		if (frac!=0) is not Infinity
+		"movn %0, $0, $9\n"		// v  = (t1!=0) ? 0 : v		if (exp!=0xFF) is not Infinity
+		".set pop\n"		
+		: "=r"(v)
+		: "f"(f)
+		: "$8", "$9"
+	);
+	return (v);
+}
+
+float pspFpuPositiveNaN(void)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui $8, 0x7F80\n"
+		"ori $8, $8, 0x0001\n"		// t0 = 0x7F800001
+		"mtc1 $8, %0\n"			// v = t0 = +SNaN(0x000001)
+		".set pop\n"		
+		: "=f"(v)
+		:
+		: "$8"
+	);
+	return (v);
+}
+
+float pspFpuNegativeNaN(void)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui $8, 0xFF80\n"
+		"ori $8, $8, 0x0001\n"		// t0 = 0xFF800001
+		"mtc1 $8, %0\n"			// v = t0 = -SNaN(0x000001)
+		".set pop\n"		
+		: "=f"(v)
+		:
+		: "$8"
+	);
+	return (v);
+}
+
+float pspFpuPositiveQNaN(void)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui $8, 0x7FC0\n"		// t0 = 0x7FC00000
+		"mtc1 $8, %0\n"			// v = t0 = +QNaN
+		".set pop\n"		
+		: "=f"(v)
+		:
+		: "$8"
+	);
+	return (v);
+}
+
+float pspFpuNegativeQNaN(void)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui $8, 0xFFC0\n"		// t0 = 0xFFC00000
+		"mtc1 $8, %0\n"			// v = t0 = -QNaN
+		".set pop\n"		
+		: "=f"(v)
+		:
+		: "$8"
+	);
+	return (v);
+}
+
+float pspFpuPositiveSNaN(unsigned int uiSignal)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"addiu $9, $0, 1\n"		// t1 = 0x00000001
+		"ext $8, %1, 0, 22\n"		// t0 = uiSignal & 0x003FFFFF
+		"movn $9, $8, $8\n"		// t1 = (t0!=0) ? t0 : t1
+		"lui $8, 0x7F80\n"		// t0 = 0x7F800000
+		"or $9, $9, $8\n"		// t1 = t1 | t0
+		"mtc1 $9, %0\n"			// v  = t1
+		".set pop\n"		
+		: "=f"(v)
+		: "r"(uiSignal)
+		: "$8", "$9"
+	);
+	return (v);
+}
+
+float pspFpuNegativeSNaN(unsigned int uiSignal)
+{
+	float v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"addiu $9, $0, 1\n"		// t1 = 0x00000001
+		"ext $8, %1, 0, 22\n"		// t0 = uiSignal & 0x003FFFFF
+		"movn $9, $8, $8\n"		// t1 = (t0!=0) ? t0 : t1
+		"lui $8, 0xFF80\n"		// t0 = 0xFF800000
+		"or $9, $9, $8\n"		// t1 = t1 | t0
+		"mtc1 $9, %0\n"			// v  = t1
+		".set pop\n"
+		: "=f"(v)
+		: "r"(uiSignal)
+		: "$8", "$9"
+	);
+	return (v);
+}
+
+int pspFpuIsNaN(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"lui %0, 0x807F\n"		//
+		"mfc1 $8, %1\n"			// t0 = f
+		"ori %0, %0, 0xFFFF\n"		// v  = 0x807FFFFF
+		"sll $9, $8, 1\n"		// t1 = t0<<1
+		"and %0, %0, $8\n"		// v  = v & t0
+		"srl $9, $9, 24\n"		// t1 = t1>>24
+		"sll $8, $8, 9\n"		// t0 = t0<<9
+		"sltiu $9, $9, 0x00FF\n"	// t1 = (t1<0xFF)
+		"movz %0, $0, $8\n"		// v  = (t0==0) ? 0 : v		if (frac==0) is not NaN
+		"movn %0, $0, $9\n"		// v  = (t1!=0) ? 0 : v		if (exp!=0xFF) is not NAN
+		".set pop\n"		
+		: "=r"(v)
+		: "f"(f)
+		: "$8", "$9"
+	);
+	return (v);
+}
+
+int pspFpuIsInfOrNaN(float f)
+{
+	int v;
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 %0, %1\n"			// v  = f
+		"sll $8, %0, 1\n"		// t0 = v<<1
+		"sra %0, %0, 30\n"		// v  = v>>30
+		"srl $8, $8, 24\n"		// t0 = t0>>24
+		"ori %0, %0, 0x0001\n"		// v  = v | 0x00000001 = (f>=0) ? +1 : -1
+		"sltiu $8, $8, 0x00FF\n"	// t0 = (t0<0xFF)
+		"movn %0, $0, $8\n"		// v  = (t0!=0) ? 0 : v		if (exp!=0xFF) is neither NAN nor Infinity
+		".set pop\n"		
+		: "=r"(v)
+		: "f"(f)
+		: "$8"
+	);
+	return (v);
+}
+
+float pspFpuNormalizePhase(float fs)
+{
+	const float f2pi = PSP_MATH_TWOPI;
+	float fd;
+
+	asm (
+		".set push\n"		
+		".set noreorder\n"	
+		"mfc1 $9,  %1\n"		// t1 = f0
+		"div.s $f0, $f0, %2\n"		// f0 = f0 / f2pi = fs / 2PI
+		"round.w.s $f0, $f0\n"		// f0 = (int)(f0+0.5)
+		"cvt.s.w $f0, $f0\n"		// f0 = float(f0)
+		"mul.s $f0, $f0, %2\n"		// f0 = f0 * f2pi = fd * 2PI
+		"sub.s %0,  %1,  $f0\n"		// fd = fs - f0   = fs - (fd * 2PI)
+		".set pop\n"		
+		: "=f"(fd)
+		: "f"(fs), "f"(f2pi)
+		: "$f0", "$8", "$9"
+	);
+	return (fd);
+}
+
+float pspFpuLog(float x)
+{
+	union {
+		float f;
+		int i;
+	} fi;
+	int a, b, exponent;
+	float y, z;
+	fi.f = x;
+	if (fi.i <= 0) {
+		if ((fi.i & 0x7fffffff) == 0) {
+			fi.i = 0xff800000; /* -INF */
+			return fi.f;
+		}
+		fi.i = 0xff80ffff; /* Quiet NaN */
+		return fi.f;
+	}
+
+	b = (fi.i & 0x007fffff);
+	a = b - (1<<23);
+	exponent = fi.i;
+	if (b <= 0x3504F3) {
+		a = b;
+		b = b - (1 << 23);
+		exponent -= (1<<23);
+	}
+	b = b - (1 << 23) + (1<<25);
+
+	x = (float)(a) / (float)(b);
+	z = (((exponent>>23)-126) * 0xB17218) * (float)(1.0/(1<<24));
+	y = x * x;
+	return z + x * (((logPoly[2] * y + logPoly[1]) * y) + logPoly[0]);
+}
+
+static float _pspFpuSinMain(float x)
+{
+	float y = x*x;
+	return x * (((triPoly[4] * y
+				+ triPoly[3]) * y
+				+ triPoly[2]) * y
+				+ triPoly[1]);
+}
+
+static float _pspFpuCosMain(float x)
+{
+	float y = x*x;
+	return ((triPoly[7] * y
+			+ triPoly[6]) * y
+			+ triPoly[5]) * y
+			+ triPoly[1];
+}
+
+static float _pspFpuAtanMain(float x)
+{
+	float y = x*x;
+	return x * (((triPoly[10] * y
+				+ triPoly[9]) * y
+				+ triPoly[8]) * y
+				+ triPoly[1]);
+}
+
+
+float pspFpuSin(float x)
+{
+	float pi2;
+	int sign = 1;
+
+	/* NaN */
+	if (x != x) {
+		return x;
+	}
+
+	pi2 = triPoly[0];
+	if (x < 0.0f) {
+		sign = -1;
+		x = -x;
+	}
+
+	if (x > pi2) {
+		float y = x / pi2;
+		x -= (float)((int)y) * pi2;
+	}
+
+	pi2 *= 0.5f;
+	if (x > pi2) {
+		x -= pi2;
+		sign = -sign;
+	}
+
+	if (x > pi2*0.5f) {
+		x = pi2 - x;
+	}
+	if (x > (float)(PSP_MATH_PI * (0.5 - COS_SIN_DIV))) {
+		return _pspFpuCosMain(pi2*0.5f - x) * sign;
+	}
+
+	return _pspFpuSinMain(x) * sign;
+}
+
+
+float pspFpuCos(float x)
+{
+	float pi2;
+	int sign = 1;
+
+	/* NaN */
+	if (x != x) {
+		return x;
+	}
+
+	pi2 = triPoly[0];
+	if (x < 0.0f) {
+		x = -x;
+	}
+
+	if (x > pi2) {
+		float y = x / pi2;
+		x -= (float)((int)y) * pi2;
+	}
+
+	pi2 *= 0.5f; // pi2 = PI
+	if (x > pi2) {
+		x -= pi2;
+		sign = -1;
+	}
+
+	if (x > pi2*0.5f) {
+		sign = -sign;
+		x = pi2 - x;
+	}
+	if (x > (float) (PSP_MATH_PI * COS_SIN_DIV)) {
+		return _pspFpuSinMain(pi2*0.5f - x) * sign;
+	}
+
+	return _pspFpuCosMain(x) * sign;
+}
+
+static float _atanf(float x)
+{
+	if (x < 0.19890f) {
+		return _pspFpuAtanMain(x);
+	}
+	if (x < 0.668106f) {
+		return (float)(PSP_MATH_PI / 8)
+			+ _pspFpuAtanMain((x - (float)(PSP_MATH_SQRT2 - 1)) / (1.0f + ((float)(PSP_MATH_SQRT2 - 1)*x)));
+	}
+	return ((float)PSP_MATH_PI / 4) + _pspFpuAtanMain((x - 1.0f) / (x + 1.0f));
+}
+
+
+float pspFpuAtan(float x)
+{
+	int sign = 1;
+
+	/* NaN */
+	if (x != x) {
+		return x;
+	}
+
+	if (x < 0.0f) {
+		x = -x;
+		sign = -1;
+	}
+	if (x >= 1.0f) {
+		/*J atan(x) = pi/2 - atan(1/x) */
+		x = 1.0f / x;
+		x = ((float)(PSP_MATH_PI / 2)) - _atanf(x);
+	} else {
+		x = _atanf(x);
+	}
+	return x * (float)sign;
+}
+
+float pspFpuAsin(float x)
+{
+	x = x*x;
+	return pspFpuAtan(__builtin_allegrex_sqrt_s(x/(1.0f-x)));
+}
+
+float pspFpuAcos(float x)
+{
+	x = x*x;
+	return pspFpuAtan(__builtin_allegrex_sqrt_s((1.0f-x)/x));
+}
Index: pspsdk/src/samples/obj-c/main.m
===================================================================
--- pspsdk/src/samples/obj-c/main.m	(revision 0)
+++ pspsdk/src/samples/obj-c/main.m	(revision 0)
@@ -0,0 +1,62 @@
+#include <objc/Object.h>
+
+@interface Greeter:Object
+{
+ /* This is left empty on purpose:
+  ** Normally instance variables would be declared here,
+  ** but these are not used in our example.
+  */
+}
+
+- (void)greet;
+
+@end
+
+
+#include <pspkernel.h>
+#include <pspdebug.h>
+#include <pspctrl.h>
+
+/* Define printf, just to make typing easier */
+#define printf  pspDebugScreenPrintf
+
+@implementation Greeter
+
+- (void)greet
+{
+	printf("Hello, World from Obj-C!\n");
+}
+
+@end
+
+/* Define the module info section */
+PSP_MODULE_INFO("template", 0, 1, 1);
+
+/* Define the main thread's attribute value (optional) */
+PSP_MAIN_THREAD_ATTR(THREAD_ATTR_USER | THREAD_ATTR_VFPU);
+
+int main(void)
+{
+	/* Non Objective-C code to allow the app to end */
+	pspDebugScreenInit();
+	SceCtrlData pad;
+	
+	/* Objective-C code */
+	id myGreeter;
+	myGreeter=[Greeter new];
+
+	[myGreeter greet];
+	[myGreeter free];
+
+	printf("\nPress X to quit.\n");
+	for (;;)
+	{
+		sceCtrlReadBufferPositive(&pad, 1);
+		if (pad.Buttons & PSP_CTRL_CROSS)
+			break;
+	}
+	sceKernelExitGame();
+	
+	return 0;
+}
+
Index: pspsdk/src/samples/obj-c/Makefile.sample
===================================================================
--- pspsdk/src/samples/obj-c/Makefile.sample	(revision 0)
+++ pspsdk/src/samples/obj-c/Makefile.sample	(revision 0)
@@ -0,0 +1,19 @@
+TARGET = ObjC
+OBJS = main.o
+
+USE_OBJC=1
+
+INCDIR =
+CFLAGS = -G0 -Wall -O2
+CXXFLAGS = $(CFLAGS) -fno-exceptions -fno-rtti
+ASFLAGS = $(CFLAGS)
+
+LIBDIR =
+LDFLAGS =
+
+EXTRA_TARGETS = EBOOT.PBP
+PSP_EBOOT_TITLE = ObjC Sample
+
+PSPSDK=$(shell psp-config --pspsdk-path)
+include $(PSPSDK)/lib/build.mak
+
Index: pspsdk/src/samples/Makefile.am
===================================================================
--- pspsdk/src/samples/Makefile.am	(revision 2458)
+++ pspsdk/src/samples/Makefile.am	(working copy)
@@ -81,7 +81,9 @@
 	utility/systemparam \
 	utility/osk \
 	me/basic \
-	wlan
+	wlan \
+	obj-c \
+	exceptions
 
 all:
 
Index: pspsdk/src/base/build_prx.mak
===================================================================
--- pspsdk/src/base/build_prx.mak	(revision 2458)
+++ pspsdk/src/base/build_prx.mak	(working copy)
@@ -37,6 +37,11 @@
 
 CFLAGS += -D_PSP_FW_VERSION=$(PSP_FW_VERSION)
 
+# Objective-C selection. All Objective C code must be linked against libobjc.a
+ifeq ($(USE_OBJC),1)
+LIBS     := $(LIBS) -lobjc
+endif
+
 # Library selection.  By default we link with Newlib's libc.  Allow the
 # user to link with PSPSDK's libc if USE_PSPSDK_LIBC is set to 1.
 
@@ -80,6 +85,12 @@
 %.c: %.exp
 	psp-build-exports -b $< > $@
 
+%.o: %.m
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+%.o: %.mm
+	$(CXX) $(CXXFLAGS) -c -o $@ $<
+
 clean: $(EXTRA_CLEAN)
 	-rm -f $(FINAL_TARGET) $(TARGET).elf $(OBJS)
 
Index: pspsdk/src/base/build.mak
===================================================================
--- pspsdk/src/base/build.mak	(revision 2458)
+++ pspsdk/src/base/build.mak	(working copy)
@@ -45,6 +45,11 @@
 CFLAGS += -D_PSP_FW_VERSION=$(PSP_FW_VERSION)
 CXXFLAGS += -D_PSP_FW_VERSION=$(PSP_FW_VERSION)
 
+# Objective-C selection. All Objective C code must be linked against libobjc.a
+ifeq ($(USE_OBJC),1)
+LIBS     := $(LIBS) -lobjc
+endif
+
 ifeq ($(BUILD_PRX),1)
 LDFLAGS  := $(addprefix -L,$(LIBDIR)) -specs=$(PSPSDK)/lib/prxspecs -Wl,-q,-T$(PSPSDK)/lib/linkfile.prx $(LDFLAGS)
 EXTRA_CLEAN += $(TARGET).elf
@@ -198,6 +203,12 @@
 %.c: %.exp
 	psp-build-exports -b $< > $@
 
+%.o: %.m
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+%.o: %.mm
+	$(CXX) $(CXXFLAGS) -c -o $@ $<
+
 clean: 
 	-rm -f $(FINAL_TARGET) $(EXTRA_CLEAN) $(OBJS) $(PSP_EBOOT_SFO) $(PSP_EBOOT) $(EXTRA_TARGETS)
 
