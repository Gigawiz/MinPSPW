Index: psplinkusb/Makefile.oe
===================================================================
--- psplinkusb/Makefile.oe	(revision 2494)
+++ psplinkusb/Makefile.oe	(working copy)
@@ -10,7 +10,7 @@
 	$(MAKE) -C boot271   release PSP_FW_VERSION=271
 
 release: clean all
-	mkdir -p release_oe/
+	mkdir -p release_oe
 	mkdir -p release_oe/pc
 	mkdir -p release_oe/psplink
 	cp -Rf scripts release_oe/scripts
Index: psplinkusb/psplink/decodeaddr.c
===================================================================
--- psplinkusb/psplink/decodeaddr.c	(revision 2494)
+++ psplinkusb/psplink/decodeaddr.c	(working copy)
@@ -43,6 +43,10 @@
 	{ 0x44000000, (2 * 1024 * 1024), MEM_ATTRIB_ALL, "VRAM (uncached)", 0 },
 	{ 0x08800000, (24 * 1024 * 1024), MEM_ATTRIB_ALL, "User memory", 0 },
 	{ 0x48800000, (24 * 1024 * 1024), MEM_ATTRIB_ALL, "User memory (uncached)", 0 },
+	{ 0x08000000, (8 * 1024 * 1024), MEM_ATTRIB_ALL, "P5", 0 },
+	{ 0x48000000, (8 * 1024 * 1024), MEM_ATTRIB_ALL, "P5 (uncached)", 0 },
+	{ 0x0A000000, (32 * 1024 * 1024), MEM_ATTRIB_ALL, "Extended memory", 0 },
+	{ 0x4A000000, (32 * 1024 * 1024), MEM_ATTRIB_ALL, "Extended memory (uncached)", 0 },
 	{ 0x88000000, (4 * 1024 * 1024), MEM_ATTRIB_ALL, "Kernel memory (low)", 0 },
 	{ 0xA8000000, (4 * 1024 * 1024), MEM_ATTRIB_ALL, "Kernel memory (low uncached)", 0 },
 	/* Don't use the following 2 on a 1.5, just crashes the psp */
Index: psplinkusb/pspsh/jetcompat.C
===================================================================
--- psplinkusb/pspsh/jetcompat.C	(revision 0)
+++ psplinkusb/pspsh/jetcompat.C	(revision 0)
@@ -0,0 +1,65 @@
+#include <stdio.h>
+#include "jetcompat.h"
+
+#if defined(__MINGW32__) && !defined(__CYGWIN__)
+void jc_perror(const char *s)
+{
+	unsigned int winerr;
+
+	winerr = WSAGetLastError();
+	
+	switch(winerr)
+	{
+    case WSAEINTR: printf("%s: Interrupted system call\n", s); return;
+    case WSAEBADF: printf("%s: Bad file number\n", s); return;
+    case WSAEACCES: printf("%s: Permission denied\n", s); return;
+    case WSAEFAULT: printf("%s: Bad address\n", s); return;
+    case WSAEINVAL: printf("%s: Invalid argument\n", s); return;
+    case WSAEMFILE: printf("%s: Too many open sockets\n", s); return;
+    case WSAEWOULDBLOCK: printf("%s: Operation would block\n", s); return;
+    case WSAEINPROGRESS: printf("%s: Operation now in progress\n", s); return;
+    case WSAEALREADY: printf("%s: Operation already in progress\n", s); return;
+    case WSAENOTSOCK: printf("%s: Socket operation on non-socket\n", s); return;
+    case WSAEDESTADDRREQ: printf("%s: Destination address required\n", s); return;
+    case WSAEMSGSIZE: printf("%s: Message too long\n", s); return;
+    case WSAEPROTOTYPE: printf("%s: Protocol wrong type for socket\n", s); return;
+    case WSAENOPROTOOPT: printf("%s: Bad protocol option\n", s); return;
+    case WSAEPROTONOSUPPORT: printf("%s: Protocol not supported\n", s); return;
+    case WSAESOCKTNOSUPPORT: printf("%s: Socket type not supported\n", s); return;
+    case WSAEOPNOTSUPP: printf("%s: Operation not supported on socket\n", s); return;
+    case WSAEPFNOSUPPORT: printf("%s: Protocol family not supported\n", s); return;
+    case WSAEAFNOSUPPORT: printf("%s: Address family not supported\n", s); return;
+    case WSAEADDRINUSE: printf("%s: Address already in use\n", s); return;
+    case WSAEADDRNOTAVAIL: printf("%s: Can't assign requested address\n", s); return;
+    case WSAENETDOWN: printf("%s: Network is down\n", s); return;
+    case WSAENETUNREACH: printf("%s: Network is unreachable\n", s); return;
+    case WSAENETRESET: printf("%s: Net connection reset\n", s); return;
+    case WSAECONNABORTED: printf("%s: Software caused connection abort\n", s); return;
+    case WSAECONNRESET: printf("%s: Connection reset by peer\n", s); return;
+    case WSAENOBUFS: printf("%s: No buffer space available\n", s); return;
+    case WSAEISCONN: printf("%s: Socket is already connected\n", s); return;
+    case WSAENOTCONN: printf("%s: Socket is not connected\n", s); return;
+    case WSAESHUTDOWN: printf("%s: Can't send after socket shutdown\n", s); return;
+    case WSAETOOMANYREFS: printf("%s: Too many references, can't splice\n", s); return;
+    case WSAETIMEDOUT: printf("%s: Connection timed out\n", s); return;
+    case WSAECONNREFUSED: printf("%s: Connection refused\n", s); return;
+    case WSAELOOP: printf("%s: Too many levels of symbolic links\n", s); return;
+    case WSAENAMETOOLONG: printf("%s: File name too long\n", s); return;
+    case WSAEHOSTDOWN: printf("%s: Host is down\n", s); return;
+    case WSAEHOSTUNREACH: printf("%s: No route to host\n", s); return;
+    case WSAENOTEMPTY: printf("%s: Directory not empty\n", s); return;
+    case WSAEPROCLIM: printf("%s: Too many processes\n", s); return;
+    case WSAEUSERS: printf("%s: Too many users\n", s); return;
+    case WSAEDQUOT: printf("%s: Disc quota exceeded\n", s); return;
+    case WSAESTALE: printf("%s: Stale NFS file handle\n", s); return;
+    case WSAEREMOTE: printf("%s: Too many levels of remote in path\n", s); return;
+    case WSASYSNOTREADY: printf("%s: Network system is unavailable\n", s); return;
+    case WSAVERNOTSUPPORTED: printf("%s: Winsock version out of range\n", s); return;
+    case WSANOTINITIALISED: printf("%s: WSAStartup not yet called\n", s); return;
+    case WSAEDISCON: printf("%s: Graceful shutdown in progress\n", s); return;
+    case WSAHOST_NOT_FOUND: printf("%s: Host not found\n", s); return;
+    case WSANO_DATA: printf("%s: No host data of that type was found\n", s); return;
+	}
+	perror(s);
+}
+#endif
Index: psplinkusb/pspsh/jetcompat.h
===================================================================
--- psplinkusb/pspsh/jetcompat.h	(revision 0)
+++ psplinkusb/pspsh/jetcompat.h	(revision 0)
@@ -0,0 +1,43 @@
+#ifndef __JETDRONE_WIN32_COMPAT
+#define __JETDRONE_WIN32_COMPAT
+#include <errno.h>
+
+#if defined(__MINGW32__) && !defined(__CYGWIN__)
+#include <conio.h>
+#include <stdio.h>
+
+#include <winsock2.h>
+
+/* This is a broken replacement since I am ignoring the 3rd argument */
+#define setenv(a,b,c) SetEnvironmentVariable(a,b)
+#define unsetenv(a) SetEnvironmentVariable(a,NULL)
+
+void jc_perror(const char *s);
+
+#define jc_socket_startup WSADATA wsaData; (void) WSAStartup(MAKEWORD(2,2), &wsaData)
+
+#define jc_socket_write(a,b,c) send(a,b,c,0)
+#define jc_socket_read(a,b,c) recv(a,(char*)b,c,0)
+#define jc_socket_close(a) closesocket(a)
+
+#else
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <fcntl.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netdb.h>
+
+#define jc_socket_startup
+
+#define jc_perror(a) perror(a)
+#define jc_socket_write(a,b,c) write(a,b,c)
+#define jc_socket_read(a,b,c) read(a,b,c)
+#define jc_socket_close(a) close(a)
+
+#define INVALID_SOCKET -1
+#define SOCKET int
+
+#endif
+
+#endif
Index: psplinkusb/pspsh/Makefile
===================================================================
--- psplinkusb/pspsh/Makefile	(revision 2494)
+++ psplinkusb/pspsh/Makefile	(working copy)
@@ -1,15 +1,31 @@
-OUTPUT=pspsh
-OBJS=pspsh.o parse_args.o pspkerror.o asm.o disasm.o
+OBJS=pspsh.o parse_args.o pspkerror.o asm.o disasm.o jetcompat.o
 
 CXXFLAGS=-Wall -g -D_PCTERM -I../psplink
 LIBS=-lreadline -lcurses
+OUTPUT=pspsh
 
+ifdef BUILD_MACOSX
+CXXFLAGS +=-I/opt/local/include
+LDFLAGS += -L/opt/local/lib
+endif
+
+ifdef BUILD_SOLARIS
+CC=cc
+CXX=CC
+LIBS +=-lsocket -lnsl
+endif
+
+ifdef BUILD_WIN32
+OUTPUT=pspsh.exe
+LIBS=-lws2_32 -lreadline
+endif
+
 PREFIX=$(shell psp-config --pspdev-path 2> /dev/null)
 
 all: $(OUTPUT)
 
 $(OUTPUT): $(OBJS)
-	$(CXX) -o $@ $^ $(LIBS)
+	$(CXX) -s -o $@ $^ $(LIBS)
 
 install: $(OUTPUT)
 	@echo "Installing $(OUTPUT)..."
Index: psplinkusb/pspsh/pspsh.C
===================================================================
--- psplinkusb/pspsh/pspsh.C	(revision 2494)
+++ psplinkusb/pspsh/pspsh.C	(working copy)
@@ -13,18 +13,13 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
-#include <sys/select.h>
-#include <sys/socket.h>
-#include <fcntl.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netdb.h>
 #include <limits.h>
 #include <readline/readline.h>
 #include <readline/history.h>
 #include <errno.h>
 #include <signal.h>
 #include <shellcmd.h>
+#include "jetcompat.h"
 #include "parse_args.h"
 #include "pspkerror.h"
 #include "disasm.h"
@@ -38,6 +32,44 @@
 #define HISTORY_FILE ".pspsh.hist"
 #define DEFAULT_IP     "localhost"
 
+#if defined(__MINGW32__)
+
+static int is_pipe = 0;
+static HANDLE input_handle = 0;
+
+int input_available()
+{
+   DWORD nchars;
+
+   /* When using Standard C input functions, also check if there
+   is anything in the buffer. After a call to such functions,
+   the input waiting in the pipe will be copied to the buffer,
+   and the call to PeekNamedPipe can indicate no input available.
+   Setting stdin to unbuffered was not enough, IIRC */
+
+   if (stdin->_cnt > 0)
+      return 1;
+
+   if (is_pipe)
+   {
+      /* When running under a GUI, you will end here. */
+
+      if (!PeekNamedPipe(input_handle, NULL, 0, NULL, &nchars, NULL))
+
+         /* Something went wrong. Probably the parent program exited.
+            Could call exit() here. Returning 1 will make the next call
+            to the input function return EOF, where this should be
+            catched then. */
+
+         return 1;
+
+      return (nchars != 0);
+   }
+   else
+      return _kbhit() != 0; /* In "text-mode" without GUI */
+}
+#endif
+
 struct Args
 {
 	const char *ip;
@@ -59,10 +91,10 @@
 	int exit;
 	int conn_sanity;
 	fd_set readsave;
-	int sock;
-	int outsock;
-	int errsock;
-	int fssock;
+	SOCKET sock;
+	SOCKET outsock;
+	SOCKET errsock;
+	SOCKET fssock;
 	char history_file[PATH_MAX];
 	char currpath[PATH_MAX];
 	char currcmd[PATH_MAX];
@@ -152,7 +184,7 @@
 }
 
 
-int fixed_write(int s, const void *buf, int len)
+int fixed_write(SOCKET s, const void *buf, int len)
 {
 	int written = 0;
 
@@ -160,12 +192,12 @@
 	{
 		int ret;
 
-		ret = write(s, (const char*) buf+written, len-written);
+		ret = jc_socket_write(s, (const char*) buf+written, len-written);
 		if(ret < 0)
 		{
 			if(errno != EINTR)
 			{
-				perror("write");
+				jc_perror("write");
 				written = -1;
 				break;
 			}
@@ -252,8 +284,8 @@
 			len = fixed_write(g_context.sock, args, binlen);
 			if(len < 0)
 			{
-				close(g_context.sock);
-				g_context.sock = -1;
+				jc_socket_close(g_context.sock);
+				g_context.sock = INVALID_SOCKET;
 				return -1;
 			}
 			strcpy(g_context.currcmd, args);
@@ -436,7 +468,7 @@
 {
 	char val[32];
 
-	snprintf(val, sizeof(val), "%d", strlen(argv[0]));
+	snprintf(val, sizeof(val), "%d", (int) strlen(argv[0]));
 	setenv("?", val, 1);
 
 	return 0;
@@ -573,12 +605,12 @@
 				snprintf(prompt, PATH_MAX, "%s> ", g_context.currpath);
 				rl_callback_handler_install(prompt, cli_handler);
 			}
-			else if(g_context.outsock >= 0)
+			else if(g_context.outsock != INVALID_SOCKET)
 			{
 				char b[1024];
 
 				snprintf(b, sizeof(b), "%s\n", buf);
-				write(g_context.outsock, b, strlen(b));
+				jc_socket_write(g_context.outsock, b, strlen(b));
 			}
 
 			return;
@@ -643,9 +675,9 @@
 		}
 		else if(buf[0] == '@')
 		{
-			if(g_context.fssock >= 0)
+			if(g_context.fssock != INVALID_SOCKET)
 			{
-				(void) write(g_context.fssock, &buf[1], strlen(&buf[1]));
+				(void) jc_socket_write(g_context.fssock, &buf[1], strlen(&buf[1]));
 			}
 			return;
 		}
@@ -816,7 +848,7 @@
 			curr += strlen(curr)+1;
 		}
 		*curr++ = 1;
-		write(g_context.sock, cmd, curr-cmd);
+		jc_socket_write(g_context.sock, cmd, curr-cmd);
 		pEntry = read_tab_completion();
 		if(pEntry == NULL)
 		{
@@ -880,7 +912,7 @@
 		strcpy(curr, text);
 		curr += strlen(curr)+1;
 		*curr++ = 1;
-		write(g_context.sock, cmd, curr-cmd);
+		jc_socket_write(g_context.sock, cmd, curr-cmd);
 		pEntry = read_tab_completion();
 	}
 
@@ -971,7 +1003,7 @@
 	rl_attempted_completion_function = shell_completion;
 	rl_callback_handler_install("", cli_handler);
 	rl_basic_word_break_characters = "\t\n ";
-	rl_completer_word_break_characters = "\t\n ";
+	rl_completer_word_break_characters = (char*) "\t\n ";
 
 	return 1;
 }
@@ -1138,7 +1170,7 @@
 
 void print_help(void)
 {
-	fprintf(stderr, "PSPSH Help (c) TyRaNiD\n");
+	fprintf(stderr, "PSPSH Help (c) TyRaNiD, Heimdall\n");
 	fprintf(stderr, "Built %s %s - $Revision: 2200 $\n", __DATE__, __TIME__);
 	fprintf(stderr, "Usage: pspsh [options] [script args...]\n");
 	fprintf(stderr, "Options:\n");
@@ -1284,7 +1316,7 @@
 
 		if(setenv(name, value, 1) < 0)
 		{
-			perror("setenv");
+			jc_perror("setenv");
 			break;
 		}
 	}
@@ -1494,7 +1526,7 @@
 	return 1;
 }
 
-int read_socket(int sock)
+int read_socket(SOCKET sock)
 {
 	static unsigned char linebuf[16*1024];
 	static int pos = 0;
@@ -1502,10 +1534,10 @@
 	unsigned char *curr;
 	int len;
 
-	len = read(sock, buf, sizeof(buf)-1);
+	len = jc_socket_read(sock, buf, sizeof(buf)-1);
 	if(len < 0)
 	{
-		perror("read");
+		jc_perror("read");
 		return -1;
 	}
 
@@ -1550,15 +1582,15 @@
 	return len;
 }
 
-int read_outsocket(int sock)
+int read_outsocket(SOCKET sock)
 {
 	char buf[1024];
 	int len;
 
-	len = read(sock, buf, sizeof(buf)-1);
+	len = jc_socket_read(sock, buf, sizeof(buf)-1);
 	if(len < 0)
 	{
-		perror("read");
+		jc_perror("read");
 		return -1;
 	}
 
@@ -1576,15 +1608,15 @@
 	return len;
 }
 
-int read_errsocket(int sock)
+int read_errsocket(SOCKET sock)
 {
 	char buf[1024];
 	int len;
 
-	len = read(sock, buf, sizeof(buf)-1);
+	len = jc_socket_read(sock, buf, sizeof(buf)-1);
 	if(len < 0)
 	{
-		perror("read");
+		jc_perror("read");
 		return -1;
 	}
 
@@ -1602,15 +1634,15 @@
 	return len;
 }
 
-int read_fssocket(int sock)
+int read_fssocket(SOCKET sock)
 {
 	char buf[1024];
 	int len;
 
-	len = read(sock, buf, sizeof(buf)-1);
+	len = jc_socket_read(sock, buf, sizeof(buf)-1);
 	if(len < 0)
 	{
-		perror("read");
+		jc_perror("read");
 		return -1;
 	}
 
@@ -1627,9 +1659,9 @@
 	return len;
 }
 
-int connect_to(const char *ipaddr, unsigned short port)
+SOCKET connect_to(const char *ipaddr, unsigned short port)
 {
-	int sock = -1;
+	SOCKET sock = INVALID_SOCKET;
 	int success = 0;
 	struct sockaddr_in name;
 
@@ -1640,15 +1672,15 @@
 			break;
 		}
 		sock = socket(PF_INET, SOCK_STREAM, 0);
-		if(sock < 0)
+		if(sock == INVALID_SOCKET)
 		{
-			perror("socket");
+			jc_perror("socket");
 			break;
 		}
 
 		if(connect(sock, (struct sockaddr *) &name, sizeof(name)) < 0)
 		{
-			perror("connect");
+			jc_perror("connect");
 			break;
 		}
 		else
@@ -1662,17 +1694,17 @@
 
 	if(!success)
 	{
-		if(sock >= 0)
+		if(sock != INVALID_SOCKET)
 		{
-			close(sock);
-			sock = -1;
+			jc_socket_close(sock);
+			sock = INVALID_SOCKET;
 		}
 	}
 
 	return sock;
 }
 
-int read_tab(int sock, struct TabEntry *head)
+int read_tab(SOCKET sock, struct TabEntry *head)
 {
 	static unsigned char linebuf[16*1024];
 	static int pos = 0;
@@ -1694,10 +1726,10 @@
 		tabcurr = tabcurr->pNext;
 	}
 
-	len = read(sock, buf, sizeof(buf)-1);
+	len = jc_socket_read(sock, buf, sizeof(buf)-1);
 	if(len < 0)
 	{
-		perror("read");
+		jc_perror("read");
 		return -1;
 	}
 
@@ -1776,7 +1808,7 @@
 	struct timeval tv;
 	struct TabEntry head;
 
-	if(g_context.sock < 0)
+	if(g_context.sock == INVALID_SOCKET)
 	{
 		return NULL;
 	}
@@ -1800,7 +1832,7 @@
 				continue;
 			}
 
-			perror("select");
+			jc_perror("select");
 			break;
 		}
 		else if(ret == 0)
@@ -1826,6 +1858,13 @@
 
 int shell(void)
 {
+#if defined(__MINGW32__)
+	/* MINGW (windows) select does not support any fd, only sockets, so this need a workaround */
+	/* I know it sucks...  pooling... */
+	struct timeval timev;
+	timev.tv_sec=0;
+	timev.tv_usec=500;
+#endif
 	fd_set readset;
 	FD_ZERO(&g_context.readsave);
 
@@ -1834,25 +1873,25 @@
 		fprintf(stderr, "Opening connection to %s port %d\n", g_context.args.ip, g_context.args.port);
 	}
 
-	if((g_context.sock = connect_to(g_context.args.ip, g_context.args.port)) < 0)
+	if((g_context.sock = connect_to(g_context.args.ip, g_context.args.port)) == INVALID_SOCKET)
 	{
 		return 1;
 	}
 
 	if(g_context.args.notty == 0)
 	{
-		if((g_context.outsock = connect_to(g_context.args.ip, g_context.args.port+2)) < 0)
+		if((g_context.outsock = connect_to(g_context.args.ip, g_context.args.port+2)) == INVALID_SOCKET)
 		{
 			fprintf(stderr, "Could not connect to stdout channel\n");
 		}
-		if((g_context.errsock = connect_to(g_context.args.ip, g_context.args.port+3)) < 0)
+		if((g_context.errsock = connect_to(g_context.args.ip, g_context.args.port+3)) == INVALID_SOCKET)
 		{
 			fprintf(stderr, "Could not connect to stderr channel\n");
 		}
 	}
 
 	/*
-	if((g_context.fssock == connect_to(g_context.args.ip, g_context.args.port+8)) < 0)
+	if((g_context.fssock == connect_to(g_context.args.ip, g_context.args.port+8)) == INVALID_SOCKET)
 	{
 		fprintf(stderr, "Could not connect to fs admin channel\n");
 	}
@@ -1863,8 +1902,9 @@
 		init_readline();
 		read_history(g_context.history_file);
 		history_set_pos(history_length);
-
+#if !defined(__MINGW32__)
 		FD_SET(STDIN_FILENO, &g_context.readsave);
+#endif
 	}
 
 	/* Change to the current directory, should return our path */
@@ -1875,6 +1915,13 @@
 		int ret;
 
 		readset = g_context.readsave;
+#if defined(__MINGW32__)
+		if(!g_context.args.script)
+		{
+			ret = select(FD_SETSIZE, &readset, NULL, NULL, &timev);
+		}
+		else
+#endif
 		ret = select(FD_SETSIZE, &readset, NULL, NULL, NULL);
 		if(ret < 0)
 		{
@@ -1883,15 +1930,24 @@
 				continue;
 			}
 
-			perror("select");
+			jc_perror("select");
 			break;
 		}
 		else if(ret == 0)
 		{
+#if defined(__MINGW32__)
+			if(!g_context.args.script)
+			{
+				if (input_available())
+					rl_callback_read_char();
+			}
+#else
 			continue;
+#endif
 		}
 		else
 		{
+#if !defined(__MINGW32__)
 			if(!g_context.args.script)
 			{
 				if(FD_ISSET(STDIN_FILENO, &readset))
@@ -1899,44 +1955,44 @@
 					rl_callback_read_char();
 				}
 			}
-
+#endif
 			if(FD_ISSET(g_context.sock, &readset))
 			{
 				/* Do read */
 				if(read_socket(g_context.sock) < 0)
 				{
-					close(g_context.sock);
-					g_context.sock = -1;
+					jc_socket_close(g_context.sock);
+					g_context.sock = INVALID_SOCKET;
 					break;
 				}
 			}
 
-			if((g_context.outsock >= 0) && FD_ISSET(g_context.outsock, &readset))
+			if((g_context.outsock != INVALID_SOCKET) && FD_ISSET(g_context.outsock, &readset))
 			{
 				if(read_outsocket(g_context.outsock) < 0)
 				{
 					FD_CLR(g_context.outsock, &g_context.readsave);
-					close(g_context.outsock);
-					g_context.outsock = -1;
+					jc_socket_close(g_context.outsock);
+					g_context.outsock = INVALID_SOCKET;
 				}
 			}
-			if((g_context.errsock >= 0) && FD_ISSET(g_context.errsock, &readset))
+			if((g_context.errsock != INVALID_SOCKET) && FD_ISSET(g_context.errsock, &readset))
 			{
 				if(read_errsocket(g_context.errsock) < 0)
 				{
 					FD_CLR(g_context.errsock, &g_context.readsave);
-					close(g_context.errsock);
-					g_context.errsock = -1;
+					jc_socket_close(g_context.errsock);
+					g_context.errsock = INVALID_SOCKET;
 				}
 			}
 
-			if((g_context.fssock >= 0) && FD_ISSET(g_context.fssock, &readset))
+			if((g_context.fssock != INVALID_SOCKET) && FD_ISSET(g_context.fssock, &readset))
 			{
 				if(read_fssocket(g_context.fssock) < 0)
 				{
 					FD_CLR(g_context.fssock, &g_context.readsave);
-					close(g_context.fssock);
-					g_context.fssock = -1;
+					jc_socket_close(g_context.fssock);
+					g_context.fssock = INVALID_SOCKET;
 				}
 			}
 					
@@ -1954,25 +2010,25 @@
 
 void shutdown_app(void)
 {
-	if(g_context.sock >= 0)
+	if(g_context.sock != INVALID_SOCKET)
 	{
-		close(g_context.sock);
-		g_context.sock = -1;
+		jc_socket_close(g_context.sock);
+		g_context.sock = INVALID_SOCKET;
 	}
-	if(g_context.outsock >= 0)
+	if(g_context.outsock != INVALID_SOCKET)
 	{
-		close(g_context.outsock);
-		g_context.outsock = -1;
+		jc_socket_close(g_context.outsock);
+		g_context.outsock = INVALID_SOCKET;
 	}
-	if(g_context.errsock >= 0)
+	if(g_context.errsock != INVALID_SOCKET)
 	{
-		close(g_context.errsock);
-		g_context.errsock = -1;
+		jc_socket_close(g_context.errsock);
+		g_context.errsock = INVALID_SOCKET;
 	}
-	if(g_context.fssock >= 0)
+	if(g_context.fssock != INVALID_SOCKET)
 	{
-		close(g_context.fssock);
-		g_context.fssock = -1;
+		jc_socket_close(g_context.fssock);
+		g_context.fssock = INVALID_SOCKET;
 	}
 
 	if(!g_context.args.script)
@@ -2016,13 +2072,20 @@
 
 int main(int argc, char **argv)
 {
+#if defined(__MINGW32__)
+   DWORD dw;
+   input_handle = GetStdHandle(STD_INPUT_HANDLE);
+   is_pipe = !GetConsoleMode(input_handle, &dw);
+#endif
+	jc_socket_startup;
+	
 	int ret = 1;
 
 	memset(&g_context, 0, sizeof(g_context));
-	g_context.sock = -1;
-	g_context.outsock = -1;
-	g_context.errsock = -1;
-	g_context.fssock = -1;
+	g_context.sock = INVALID_SOCKET;
+	g_context.outsock = INVALID_SOCKET;
+	g_context.errsock = INVALID_SOCKET;
+	g_context.fssock = INVALID_SOCKET;
 	g_context.fstdout = stdout;
 	g_context.fstderr = stderr;
 	if(parse_args(argc, argv, &g_context.args))
Index: psplinkusb/tools/remotejoy/pc/Makefile
===================================================================
--- psplinkusb/tools/remotejoy/pc/Makefile	(revision 2494)
+++ psplinkusb/tools/remotejoy/pc/Makefile	(working copy)
@@ -5,6 +5,17 @@
 
 PREFIX=$(shell psp-config --pspdev-path 2> /dev/null)
 
+ifdef BUILD_SOLARIS
+CC=cc
+CXX=CC
+LIBS +=-lnsl -lsocket
+endif
+
+ifdef BUILD_WIN32
+OUTPUT=remotejoy.exe
+LIBS +=-lws2_32
+endif
+
 all: $(OUTPUT)
 
 $(OUTPUT): $(OBJS)
Index: psplinkusb/tools/remotejoy/pcsdl/jetcompat.c
===================================================================
--- psplinkusb/tools/remotejoy/pcsdl/jetcompat.c	(revision 0)
+++ psplinkusb/tools/remotejoy/pcsdl/jetcompat.c	(revision 0)
@@ -0,0 +1,65 @@
+#include <stdio.h>
+#include "jetcompat.h"
+
+#if defined(__MINGW32__) && !defined(__CYGWIN__)
+void jc_perror(const char *s)
+{
+	unsigned int winerr;
+
+	winerr = WSAGetLastError();
+	
+	switch(winerr)
+	{
+    case WSAEINTR: printf("%s: Interrupted system call\n", s); return;
+    case WSAEBADF: printf("%s: Bad file number\n", s); return;
+    case WSAEACCES: printf("%s: Permission denied\n", s); return;
+    case WSAEFAULT: printf("%s: Bad address\n", s); return;
+    case WSAEINVAL: printf("%s: Invalid argument\n", s); return;
+    case WSAEMFILE: printf("%s: Too many open sockets\n", s); return;
+    case WSAEWOULDBLOCK: printf("%s: Operation would block\n", s); return;
+    case WSAEINPROGRESS: printf("%s: Operation now in progress\n", s); return;
+    case WSAEALREADY: printf("%s: Operation already in progress\n", s); return;
+    case WSAENOTSOCK: printf("%s: Socket operation on non-socket\n", s); return;
+    case WSAEDESTADDRREQ: printf("%s: Destination address required\n", s); return;
+    case WSAEMSGSIZE: printf("%s: Message too long\n", s); return;
+    case WSAEPROTOTYPE: printf("%s: Protocol wrong type for socket\n", s); return;
+    case WSAENOPROTOOPT: printf("%s: Bad protocol option\n", s); return;
+    case WSAEPROTONOSUPPORT: printf("%s: Protocol not supported\n", s); return;
+    case WSAESOCKTNOSUPPORT: printf("%s: Socket type not supported\n", s); return;
+    case WSAEOPNOTSUPP: printf("%s: Operation not supported on socket\n", s); return;
+    case WSAEPFNOSUPPORT: printf("%s: Protocol family not supported\n", s); return;
+    case WSAEAFNOSUPPORT: printf("%s: Address family not supported\n", s); return;
+    case WSAEADDRINUSE: printf("%s: Address already in use\n", s); return;
+    case WSAEADDRNOTAVAIL: printf("%s: Can't assign requested address\n", s); return;
+    case WSAENETDOWN: printf("%s: Network is down\n", s); return;
+    case WSAENETUNREACH: printf("%s: Network is unreachable\n", s); return;
+    case WSAENETRESET: printf("%s: Net connection reset\n", s); return;
+    case WSAECONNABORTED: printf("%s: Software caused connection abort\n", s); return;
+    case WSAECONNRESET: printf("%s: Connection reset by peer\n", s); return;
+    case WSAENOBUFS: printf("%s: No buffer space available\n", s); return;
+    case WSAEISCONN: printf("%s: Socket is already connected\n", s); return;
+    case WSAENOTCONN: printf("%s: Socket is not connected\n", s); return;
+    case WSAESHUTDOWN: printf("%s: Can't send after socket shutdown\n", s); return;
+    case WSAETOOMANYREFS: printf("%s: Too many references, can't splice\n", s); return;
+    case WSAETIMEDOUT: printf("%s: Connection timed out\n", s); return;
+    case WSAECONNREFUSED: printf("%s: Connection refused\n", s); return;
+    case WSAELOOP: printf("%s: Too many levels of symbolic links\n", s); return;
+    case WSAENAMETOOLONG: printf("%s: File name too long\n", s); return;
+    case WSAEHOSTDOWN: printf("%s: Host is down\n", s); return;
+    case WSAEHOSTUNREACH: printf("%s: No route to host\n", s); return;
+    case WSAENOTEMPTY: printf("%s: Directory not empty\n", s); return;
+    case WSAEPROCLIM: printf("%s: Too many processes\n", s); return;
+    case WSAEUSERS: printf("%s: Too many users\n", s); return;
+    case WSAEDQUOT: printf("%s: Disc quota exceeded\n", s); return;
+    case WSAESTALE: printf("%s: Stale NFS file handle\n", s); return;
+    case WSAEREMOTE: printf("%s: Too many levels of remote in path\n", s); return;
+    case WSASYSNOTREADY: printf("%s: Network system is unavailable\n", s); return;
+    case WSAVERNOTSUPPORTED: printf("%s: Winsock version out of range\n", s); return;
+    case WSANOTINITIALISED: printf("%s: WSAStartup not yet called\n", s); return;
+    case WSAEDISCON: printf("%s: Graceful shutdown in progress\n", s); return;
+    case WSAHOST_NOT_FOUND: printf("%s: Host not found\n", s); return;
+    case WSANO_DATA: printf("%s: No host data of that type was found\n", s); return;
+	}
+	perror(s);
+}
+#endif
Index: psplinkusb/tools/remotejoy/pcsdl/jetcompat.h
===================================================================
--- psplinkusb/tools/remotejoy/pcsdl/jetcompat.h	(revision 0)
+++ psplinkusb/tools/remotejoy/pcsdl/jetcompat.h	(revision 0)
@@ -0,0 +1,43 @@
+#ifndef __JETDRONE_WIN32_COMPAT
+#define __JETDRONE_WIN32_COMPAT
+#include <errno.h>
+
+#if defined(__MINGW32__) && !defined(__CYGWIN__)
+#include <conio.h>
+#include <stdio.h>
+
+#include <winsock2.h>
+
+/* This is a broken replacement since I am ignoring the 3rd argument */
+#define setenv(a,b,c) SetEnvironmentVariable(a,b)
+#define unsetenv(a) SetEnvironmentVariable(a,NULL)
+
+void jc_perror(const char *s);
+
+#define jc_socket_startup WSADATA wsaData; (void) WSAStartup(MAKEWORD(2,2), &wsaData)
+
+#define jc_socket_write(a,b,c) send(a,b,c,0)
+#define jc_socket_read(a,b,c) recv(a,(char*)b,c,0)
+#define jc_socket_close(a) closesocket(a)
+
+#else
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <fcntl.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netdb.h>
+
+#define jc_socket_startup
+
+#define jc_perror(a) perror(a)
+#define jc_socket_write(a,b,c) write(a,b,c)
+#define jc_socket_read(a,b,c) read(a,b,c)
+#define jc_socket_close(a) close(a)
+
+#define INVALID_SOCKET -1
+#define SOCKET int
+
+#endif
+
+#endif
Index: psplinkusb/tools/remotejoy/pcsdl/Makefile
===================================================================
--- psplinkusb/tools/remotejoy/pcsdl/Makefile	(revision 2494)
+++ psplinkusb/tools/remotejoy/pcsdl/Makefile	(working copy)
@@ -1,14 +1,26 @@
-OUTPUT=remotejoy
-OBJS=remotejoy.o font.o
+OBJS=remotejoy.o font.o jetcompat.o
 
-CFLAGS=-O2 -Wall -g $(shell sdl-config --cflags)
+CFLAGS=-O2 -W -Wall -g $(shell sdl-config --cflags)
 
 PREFIX=$(shell psp-config --pspdev-path 2> /dev/null)
+OUTPUT=remotejoy
+LIBS=$(shell sdl-config --libs)
 
+ifdef BUILD_SOLARIS
+CC=cc
+CXX=CC
+LIBS +=-lnsl -lsocket
+endif
+
+ifdef BUILD_WIN32
+OUTPUT=remotejoy.exe
+LIBS +=-lws2_32
+endif
+
 all: $(OUTPUT)
 
 $(OUTPUT): $(OBJS)
-	$(CC) -o $@ $^ $(shell sdl-config --libs)
+	$(CC) -s -o $@ $^ $(LIBS)
 
 install: $(OUTPUT)
 	@echo "Installing $(OUTPUT)..."
Index: psplinkusb/tools/remotejoy/pcsdl/remotejoy.c
===================================================================
--- psplinkusb/tools/remotejoy/pcsdl/remotejoy.c	(revision 2494)
+++ psplinkusb/tools/remotejoy/pcsdl/remotejoy.c	(working copy)
@@ -13,14 +13,8 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
-#include <sys/select.h>
-#include <sys/socket.h>
 #include <sys/stat.h>
-#include <fcntl.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netdb.h>
 #include <limits.h>
 #include <errno.h>
 #include <ctype.h>
 #include <signal.h>
@@ -28,6 +21,7 @@
 #include <SDL.h>
 #include <SDL_thread.h>
 #include "../remotejoy.h"
+#include "jetcompat.h"
 
 #define DEFAULT_PORT 10004
 #define DEFAULT_IP   "localhost"
@@ -212,7 +206,7 @@
 
 #define VERBOSE (g_context.args.verbose)
 
-int fixed_write(int s, const void *buf, int len)
+int fixed_write(SOCKET s, const void *buf, int len)
 {
 	int written = 0;
 
@@ -220,12 +214,12 @@
 	{
 		int ret;
 
-		ret = write(s, buf+written, len-written);
+		ret = jc_socket_write(s, buf+written, len-written);
 		if(ret < 0)
 		{
 			if(errno != EINTR)
 			{
-				perror("write");
+				jc_perror("write");
 				written = -1;
 				break;
 			}
@@ -335,36 +329,36 @@
 	return 1;
 }
 
-int connect_to(const char *ipaddr, unsigned short port)
+SOCKET connect_to(const char *ipaddr, unsigned short port)
 {
 	struct sockaddr_in name;
-	int sock = -1;
+	SOCKET sock = INVALID_SOCKET;
 	int flag = 1;
 
 	sock = socket(PF_INET, SOCK_STREAM, 0);
 
-	if(sock < 0)
+	if(sock == INVALID_SOCKET)
 	{
-		perror("socket");
-		return -1;
+		jc_perror("socket");
+		return INVALID_SOCKET;
 	}
 
 	if(!init_sockaddr(&name, ipaddr, port))
 	{
 		printf("Could not initialise socket address\n");
-		close(sock);
-		return -1;
+		jc_socket_close(sock);
+		return INVALID_SOCKET;
 	}
 
 	if(connect(sock, (struct sockaddr *) &name, sizeof(name)) < 0)
 	{
-		perror("connect");
-		close(sock);
-		return -1;
+		jc_perror("connect");
+		jc_socket_close(sock);
+		return INVALID_SOCKET;
 	}
 
 	/* Disable NAGLE's algorithm to prevent the packets being joined */
-	setsockopt(sock, SOL_TCP, TCP_NODELAY, &flag, sizeof(int));
+	setsockopt(sock, SOL_TCP, TCP_NODELAY,  (char*)&flag, sizeof(int));
 
 	return sock;
 }
@@ -504,11 +498,11 @@
 	return 1;
 }
 
-int send_event(int sock, int type, unsigned int value)
+int send_event(SOCKET sock, int type, unsigned int value)
 {
 	struct JoyEvent event;
 
-	if(sock < 0)
+	if(sock == INVALID_SOCKET)
 	{
 		return 0;
 	}
@@ -539,7 +533,7 @@
 	SDL_PushEvent(&event);
 }
 
-int flush_socket(int sock)
+int flush_socket(SOCKET sock)
 {
 	/* If we encounter some horrible error which means we are desynced
 	 * then send a video off packet to remotejoy, wait around for a second sucking up
@@ -582,7 +576,7 @@
 	int frame = 0;
 	fd_set saveset, readset;
 	int count;
-	int sock = *(int *) p;
+	SOCKET sock = *(SOCKET *) p;
 	struct JoyScrHeader head;
 
 	FD_ZERO(&saveset);
@@ -602,7 +596,7 @@
 
 			if(FD_ISSET(sock, &readset))
 			{
-				ret = read(sock, &head, sizeof(head));
+				ret = jc_socket_read(sock, &head, sizeof(head));
 				if((ret != sizeof(head)) || (LE32(head.magic) != JOY_MAGIC))
 				{
 					fprintf(stderr, "Error in socket %d, magic %08X\n", ret, head.magic);
@@ -647,12 +641,12 @@
 						count = select(FD_SETSIZE, &readset, NULL, NULL, NULL);
 						if(count > 0)
 						{
-							ret = read(sock, &(g_buffers[frame].buf[loc]), size-loc);
+							ret = jc_socket_read(sock, &(g_buffers[frame].buf[loc]), size-loc);
 							if(ret < 0)
 							{
 								if(errno != EINTR)
 								{
-									perror("read:");
+									jc_perror("read:");
 									err = 1;
 									break;
 								}
@@ -674,7 +668,7 @@
 						{
 							if(errno != EINTR)
 							{
-								perror("select:");
+								jc_perror("select:");
 								err = 1;
 								break;
 							}
@@ -700,7 +694,7 @@
 		{
 			if(errno != EINTR)
 			{
-				perror("select:");
+				jc_perror("select:");
 				err = 1;
 			}
 		}
@@ -805,7 +799,7 @@
 	SDL_Thread *thread = NULL;
 	int currw, currh;
 	int sdl_init = 0;
-	int sock = -1;
+	SOCKET sock = INVALID_SOCKET;
 	unsigned int button_state = 0;
 	int currmode[2] = { 3, 3 };
 	int flags = SDL_HWSURFACE;
@@ -902,7 +896,7 @@
 		}
 
 		sock = connect_to(g_context.args.ip, g_context.args.port);
-		if(sock < 0)
+		if(sock == INVALID_SOCKET)
 		{
 			break;
 		}
@@ -1324,9 +1318,9 @@
 		SDL_Quit();
 	}
 
-	if(sock >= 0)
+	if(sock != INVALID_SOCKET)
 	{
-		close(sock);
+		jc_socket_close(sock);
 	}
 
 	if(g_buttmap)
@@ -1339,7 +1333,9 @@
 
 int main(int argc, char **argv)
 {
-	fprintf(stderr, "Remote Joy SDL for PSP (c) TyRaNiD 2k6\n");
+	jc_socket_startup;
+	jc_perror("main");
+	fprintf(stderr, "Remote Joy SDL for PSP (c) TyRaNiD, jetdrone 2k10\n");
 	fprintf(stderr, "Built %s %s - $Revision: 2398 $\n", __DATE__, __TIME__);
 	memset(&g_context, 0, sizeof(g_context));
 	if(parse_args(argc, argv, &g_context.args))
Index: psplinkusb/usbhostfs_pc/main.c
===================================================================
--- psplinkusb/usbhostfs_pc/main.c	(revision 2494)
+++ psplinkusb/usbhostfs_pc/main.c	(working copy)
@@ -16,7 +16,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <ctype.h>
-#include <usb.h>
 #include <limits.h>
 #include <fcntl.h>
 #include <usbhostfs.h>
@@ -52,6 +51,7 @@
 #include <readline/history.h>
 #endif
 
+#include "jetcompat.h"
 #include "psp_fileio.h"
 
 #define MAX_FILES 256
Index: psplinkusb/usbhostfs_pc/jetcompat.c
===================================================================
--- psplinkusb/usbhostfs_pc/jetcompat.c	(revision 0)
+++ psplinkusb/usbhostfs_pc/jetcompat.c	(revision 0)
@@ -0,0 +1,729 @@
+#ifdef BUILD_LIBUSB10
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "jetcompat.h"
+
+/*
+ * Various libusb API related stuff
+ */
+#define USB_ENDPOINT_IN			0x80
+#define USB_ENDPOINT_OUT		0x00
+#define USB_DT_CONFIG_SIZE		9
+#define USB_DT_INTERFACE_SIZE		9
+#define USB_DT_ENDPOINT_AUDIO_SIZE	9	/* Audio extension */
+
+/* Some quick and generic macros for the simple kind of lists we use */
+#define LIST_ADD(begin, ent) \
+	do { \
+	  if (begin) { \
+	    ent->next = begin; \
+	    ent->next->prev = ent; \
+	  } else \
+	    ent->next = NULL; \
+	  ent->prev = NULL; \
+	  begin = ent; \
+	} while(0)
+
+#define LIST_DEL(begin, ent) \
+	do { \
+	  if (ent->prev) \
+	    ent->prev->next = ent->next; \
+	  else \
+	    begin = ent->next; \
+	  if (ent->next) \
+	    ent->next->prev = ent->prev; \
+	  ent->prev = NULL; \
+	  ent->next = NULL; \
+	} while (0)
+
+struct usb_dev_handle {
+	libusb_device_handle *handle;
+	struct usb_device *device;
+
+	/* libusb-0.1 is buggy w.r.t. interface claiming. it allows you to claim
+	 * multiple interfaces but only tracks the most recently claimed one,
+	 * which is used for usb_set_altinterface(). we clone the buggy behaviour
+	 * here. */
+	int last_claimed_interface;
+};
+
+struct usb_endpoint_descriptor {
+	u_int8_t  bLength;
+	u_int8_t  bDescriptorType;
+	u_int8_t  bEndpointAddress;
+	u_int8_t  bmAttributes;
+	u_int16_t wMaxPacketSize;
+	u_int8_t  bInterval;
+	u_int8_t  bRefresh;
+	u_int8_t  bSynchAddress;
+
+	unsigned char *extra;	/* Extra descriptors */
+	int extralen;
+};
+
+struct usb_interface_descriptor {
+	u_int8_t  bLength;
+	u_int8_t  bDescriptorType;
+	u_int8_t  bInterfaceNumber;
+	u_int8_t  bAlternateSetting;
+	u_int8_t  bNumEndpoints;
+	u_int8_t  bInterfaceClass;
+	u_int8_t  bInterfaceSubClass;
+	u_int8_t  bInterfaceProtocol;
+	u_int8_t  iInterface;
+
+	struct usb_endpoint_descriptor *endpoint;
+
+	unsigned char *extra;	/* Extra descriptors */
+	int extralen;
+};
+
+struct usb_interface {
+	struct usb_interface_descriptor *altsetting;
+
+	int num_altsetting;
+};
+
+struct usb_config_descriptor {
+	u_int8_t  bLength;
+	u_int8_t  bDescriptorType;
+	u_int16_t wTotalLength;
+	u_int8_t  bNumInterfaces;
+	u_int8_t  bConfigurationValue;
+	u_int8_t  iConfiguration;
+	u_int8_t  bmAttributes;
+	u_int8_t  MaxPower;
+
+	struct usb_interface *interface;
+
+	unsigned char *extra;	/* Extra descriptors */
+	int extralen;
+};
+
+struct usb_bus *usb_busses = NULL;
+static libusb_context *ctx = NULL;
+
+#define compat_err(e) -(errno=libusb_to_errno(e))
+
+static int libusb_to_errno(int result)
+{
+	switch (result) {
+	case LIBUSB_SUCCESS:
+		return 0;
+	case LIBUSB_ERROR_IO:
+		return EIO;
+	case LIBUSB_ERROR_INVALID_PARAM:
+		return EINVAL;
+	case LIBUSB_ERROR_ACCESS:
+		return EACCES;
+	case LIBUSB_ERROR_NO_DEVICE:
+		return ENXIO;
+	case LIBUSB_ERROR_NOT_FOUND:
+		return ENOENT;
+	case LIBUSB_ERROR_BUSY:
+		return EBUSY;
+	case LIBUSB_ERROR_TIMEOUT:
+		return ETIMEDOUT;
+	case LIBUSB_ERROR_OVERFLOW:
+		return EOVERFLOW;
+	case LIBUSB_ERROR_PIPE:
+		return EPIPE;
+	case LIBUSB_ERROR_INTERRUPTED:
+		return EINTR;
+	case LIBUSB_ERROR_NO_MEM:
+		return ENOMEM;
+	case LIBUSB_ERROR_NOT_SUPPORTED:
+		return ENOSYS;
+	default:
+		return ERANGE;
+	}
+}
+
+void usb_init(void)
+{
+	int r;
+	if (!ctx) {
+		r = libusb_init(&ctx);
+		if (r < 0) {
+			fprintf(stderr, "usb: error: %s: %s\n", "initialization failed!", __FUNCTION__);
+			return;
+		}
+	}
+}
+
+int usb_close(usb_dev_handle *dev)
+{
+	libusb_close(dev->handle);
+	free(dev);
+	return 0;
+}
+
+int usb_reset(usb_dev_handle *dev)
+{
+	return compat_err(libusb_reset_device(dev->handle));
+}
+
+int usb_set_configuration(usb_dev_handle *dev, int configuration)
+{
+	return compat_err(libusb_set_configuration(dev->handle, configuration));
+}
+
+static int usb_bulk_io(usb_dev_handle *dev, int ep, char *bytes, int size, int timeout)
+{
+	int actual_length;
+	int r;
+	r = libusb_bulk_transfer(dev->handle, ep & 0xff, bytes, size, &actual_length, timeout);
+	
+	/* if we timed out but did transfer some data, report as successful short
+	 * read. FIXME: is this how libusb-0.1 works? */
+	if (r == 0 || (r == LIBUSB_ERROR_TIMEOUT && actual_length > 0))
+		return actual_length;
+
+	return compat_err(r);
+}
+
+int usb_bulk_read(usb_dev_handle *dev, int ep, char *bytes, int size, int timeout)
+{
+	if (!(ep & USB_ENDPOINT_IN)) {
+		/* libusb-0.1 will strangely fix up a read request from endpoint
+		 * 0x01 to be from endpoint 0x81. do the same thing here, but
+		 * warn about this silly behaviour. */
+		fprintf(stderr, "usb: warn: %s: %s\n", "endpoint is missing IN direction bit, fixing", __FUNCTION__);
+		ep |= USB_ENDPOINT_IN;
+	}
+
+	return usb_bulk_io(dev, ep, bytes, size, timeout);
+}
+
+int usb_bulk_write(usb_dev_handle *dev, int ep, char *bytes, int size, int timeout)
+{
+	if (ep & USB_ENDPOINT_IN) {
+		/* libusb-0.1 on BSD strangely fix up a write request to endpoint
+		 * 0x81 to be to endpoint 0x01. do the same thing here, but
+		 * warn about this silly behaviour. */
+		fprintf(stderr, "usb: warn: %s: %s\n", "endpoint is missing IN direction bit, fixing", __FUNCTION__);
+		ep &= ~USB_ENDPOINT_IN;
+	}
+
+	return usb_bulk_io(dev, ep, bytes, size, timeout);
+}
+
+int usb_release_interface(usb_dev_handle *dev, int interface)
+{
+	int r;
+
+	r = libusb_release_interface(dev->handle, interface);
+	if (r == 0)
+		dev->last_claimed_interface = -1;
+
+	return compat_err(r);
+}
+
+int usb_claim_interface(usb_dev_handle *dev, int interface)
+{
+	int r;
+
+	r = libusb_claim_interface(dev->handle, interface);
+	if (r == 0) {
+		dev->last_claimed_interface = interface;
+		return 0;
+	}
+
+	return compat_err(r);
+}
+
+static int find_busses(struct usb_bus **ret)
+{
+	libusb_device **dev_list = NULL;
+	struct usb_bus *busses = NULL;
+	struct usb_bus *bus;
+	int dev_list_len = 0;
+	int i;
+	int r;
+
+	r = libusb_get_device_list(ctx, &dev_list);
+	if (r < 0) {
+		fprintf(stderr, "usb: get_device_list failed with error %d: %s", r, __FUNCTION__);
+		return compat_err(r);
+	}
+
+	if (r == 0) {
+		libusb_free_device_list(dev_list, 1);
+		/* no buses */
+		return 0;
+	}
+
+	/* iterate over the device list, identifying the individual busses.
+	 * we use the location field of the usb_bus structure to store the
+	 * bus number. */
+
+	dev_list_len = r;
+	for (i = 0; i < dev_list_len; i++) {
+		libusb_device *dev = dev_list[i];
+		uint8_t bus_num = libusb_get_bus_number(dev);
+
+		/* if we already know about it, continue */
+		if (busses) {
+			bus = busses;
+			int found = 0;
+			do {
+				if (bus_num == bus->location) {
+					found = 1;
+					break;
+				}
+			} while ((bus = bus->next) != NULL);
+			if (found)
+				continue;
+		}
+
+		/* add it to the list of busses */
+		bus = malloc(sizeof(*bus));
+		if (!bus)
+			goto err;
+
+		memset(bus, 0, sizeof(*bus));
+		bus->location = bus_num;
+		sprintf(bus->dirname, "%03d", bus_num);
+		LIST_ADD(busses, bus);
+	}
+
+	libusb_free_device_list(dev_list, 1);
+	*ret = busses;
+	return 0;
+
+err:
+	bus = busses;
+	while (bus) {
+		struct usb_bus *tbus = bus->next;
+		free(bus);
+		bus = tbus;
+	}
+	return -ENOMEM;
+}
+
+int usb_find_busses(void)
+{
+	struct usb_bus *new_busses = NULL;
+	struct usb_bus *bus;
+	int changes = 0;
+	int r;
+
+	/* libusb-1.0 initialization might have failed, but we can't indicate
+	 * this with libusb-0.1, so trap that situation here */
+	if (!ctx)
+		return 0;
+	
+	r = find_busses(&new_busses);
+	if (r < 0) {
+		fprintf(stderr, "usb: find_busses failed with error %d: %s\n", r, __FUNCTION__);
+		return r;
+	}
+
+	/* walk through all busses we already know about, removing duplicates
+	 * from the new list. if we do not find it in the new list, the bus
+	 * has been removed. */
+
+	bus = usb_busses;
+	while (bus) {
+		struct usb_bus *tbus = bus->next;
+		struct usb_bus *nbus = new_busses;
+		int found = 0;
+
+		while (nbus) {
+			struct usb_bus *tnbus = nbus->next;
+
+			if (bus->location == nbus->location) {
+				LIST_DEL(new_busses, nbus);
+				free(nbus);
+				found = 1;
+				break;
+			}
+			nbus = tnbus;
+		}
+
+		if (!found) {
+			/* bus removed */
+			changes++;
+			LIST_DEL(usb_busses, bus);
+			free(bus);
+		}
+
+		bus = tbus;
+	}
+
+	/* anything remaining in new_busses is a new bus */
+	bus = new_busses;
+	while (bus) {
+		struct usb_bus *tbus = bus->next;
+		LIST_DEL(new_busses, bus);
+		LIST_ADD(usb_busses, bus);
+		changes++;
+		bus = tbus;
+	}
+
+	return changes;
+}
+
+usb_dev_handle *usb_open(struct usb_device *dev)
+{
+	int r;
+
+	usb_dev_handle *udev = malloc(sizeof(*udev));
+	if (!udev)
+		return NULL;
+
+	r = libusb_open((libusb_device *) dev->dev, &udev->handle);
+	if (r < 0) {
+		fprintf(stderr, "usb: could not open device, error %d: %s\n", r, __FUNCTION__);
+		free(udev);
+		errno = libusb_to_errno(r);
+		return NULL;
+	}
+
+	udev->last_claimed_interface = -1;
+	udev->device = dev;
+	return udev;
+}
+
+static int find_devices(libusb_device **dev_list, int dev_list_len,
+	struct usb_bus *bus, struct usb_device **ret)
+{
+	struct usb_device *devices = NULL;
+	struct usb_device *dev;
+	int i;
+
+	for (i = 0; i < dev_list_len; i++) {
+		libusb_device *newlib_dev = dev_list[i];
+		uint8_t bus_num = libusb_get_bus_number(newlib_dev);
+
+		if (bus_num != bus->location)
+			continue;
+
+		dev = malloc(sizeof(*dev));
+		if (!dev)
+			goto err;
+
+		/* No need to reference the device now, just take the pointer. We
+		 * increase the reference count later if we keep the device. */
+		dev->dev = newlib_dev;
+
+		dev->bus = bus;
+		dev->devnum = libusb_get_device_address(newlib_dev);
+		sprintf(dev->filename, "%03d", dev->devnum);
+		LIST_ADD(devices, dev);
+	}
+
+	*ret = devices;
+	return 0;
+
+err:
+	dev = devices;
+	while (dev) {
+		struct usb_device *tdev = dev->next;
+		free(dev);
+		dev = tdev;
+	}
+	return -ENOMEM;
+}
+
+static void clear_endpoint_descriptor(struct usb_endpoint_descriptor *ep)
+{
+	if (ep->extra)
+		free(ep->extra);
+}
+
+static void clear_interface_descriptor(struct usb_interface_descriptor *iface)
+{
+	if (iface->extra)
+		free(iface->extra);
+	if (iface->endpoint) {
+		int i;
+		for (i = 0; i < iface->bNumEndpoints; i++)
+			clear_endpoint_descriptor(iface->endpoint + i);
+		free(iface->endpoint);
+	}
+}
+
+static void clear_interface(struct usb_interface *iface)
+{
+	if (iface->altsetting) {
+		int i;
+		for (i = 0; i < iface->num_altsetting; i++)
+			clear_interface_descriptor(iface->altsetting + i);
+		free(iface->altsetting);
+	}
+}
+
+static void clear_config_descriptor(struct usb_config_descriptor *config)
+{
+	if (config->extra)
+		free(config->extra);
+	if (config->interface) {
+		int i;
+		for (i = 0; i < config->bNumInterfaces; i++)
+			clear_interface(config->interface + i);
+		free(config->interface);
+	}
+}
+
+static void clear_device(struct usb_device *dev)
+{
+	int i;
+	for (i = 0; i < dev->descriptor.bNumConfigurations; i++)
+		clear_config_descriptor(dev->config + i);
+}
+
+static void free_device(struct usb_device *dev)
+{
+	clear_device(dev);
+	libusb_unref_device(dev->dev);
+	free(dev);
+}
+
+static int copy_endpoint_descriptor(struct usb_endpoint_descriptor *dest,
+	const struct libusb_endpoint_descriptor *src)
+{
+	memcpy(dest, src, USB_DT_ENDPOINT_AUDIO_SIZE);
+
+	dest->extralen = src->extra_length;
+	if (src->extra_length) {
+		dest->extra = malloc(src->extra_length);
+		if (!dest->extra)
+			return -ENOMEM;
+		memcpy(dest->extra, src->extra, src->extra_length);
+	}
+
+	return 0;
+}
+
+static int copy_interface_descriptor(struct usb_interface_descriptor *dest,
+	const struct libusb_interface_descriptor *src)
+{
+	int i;
+	int num_endpoints = src->bNumEndpoints;
+	size_t alloc_size = sizeof(struct usb_endpoint_descriptor) * num_endpoints;
+
+	memcpy(dest, src, USB_DT_INTERFACE_SIZE);
+	dest->endpoint = malloc(alloc_size);
+	if (!dest->endpoint)
+		return -ENOMEM;
+	memset(dest->endpoint, 0, alloc_size);
+
+	for (i = 0; i < num_endpoints; i++) {
+		int r = copy_endpoint_descriptor(dest->endpoint + i, &src->endpoint[i]);
+		if (r < 0) {
+			clear_interface_descriptor(dest);
+			return r;
+		}
+	}
+
+	dest->extralen = src->extra_length;
+	if (src->extra_length) {
+		dest->extra = malloc(src->extra_length);
+		if (!dest->extra) {
+			clear_interface_descriptor(dest);
+			return -ENOMEM;
+		}
+		memcpy(dest->extra, src->extra, src->extra_length);
+	}
+
+	return 0;
+}
+
+static int copy_interface(struct usb_interface *dest,
+	const struct libusb_interface *src)
+{
+	int i;
+	int num_altsetting = src->num_altsetting;
+	size_t alloc_size = sizeof(struct usb_interface_descriptor)
+		* num_altsetting;
+
+	dest->num_altsetting = num_altsetting;
+	dest->altsetting = malloc(alloc_size);
+	if (!dest->altsetting)
+		return -ENOMEM;
+	memset(dest->altsetting, 0, alloc_size);
+
+	for (i = 0; i < num_altsetting; i++) {
+		int r = copy_interface_descriptor(dest->altsetting + i,
+			&src->altsetting[i]);
+		if (r < 0) {
+			clear_interface(dest);
+			return r;
+		}
+	}
+
+	return 0;
+}
+
+static int copy_config_descriptor(struct usb_config_descriptor *dest,
+	const struct libusb_config_descriptor *src)
+{
+	int i;
+	int num_interfaces = src->bNumInterfaces;
+	size_t alloc_size = sizeof(struct usb_interface) * num_interfaces;
+
+	memcpy(dest, src, USB_DT_CONFIG_SIZE);
+	dest->interface = malloc(alloc_size);
+	if (!dest->interface)
+		return -ENOMEM;
+	memset(dest->interface, 0, alloc_size);
+
+	for (i = 0; i < num_interfaces; i++) {
+		int r = copy_interface(dest->interface + i, &src->interface[i]);
+		if (r < 0) {
+			clear_config_descriptor(dest);
+			return r;
+		}
+	}
+
+	dest->extralen = src->extra_length;
+	if (src->extra_length) {
+		dest->extra = malloc(src->extra_length);
+		if (!dest->extra) {
+			clear_config_descriptor(dest);
+			return -ENOMEM;
+		}
+		memcpy(dest->extra, src->extra, src->extra_length);
+	}
+
+	return 0;
+}
+
+static int initialize_device(struct usb_device *dev)
+{
+	libusb_device *newlib_dev = dev->dev;
+	int num_configurations;
+	size_t alloc_size;
+	int r;
+	int i;
+
+	/* device descriptor is identical in both libs */
+	r = libusb_get_device_descriptor(newlib_dev,
+		(struct libusb_device_descriptor *) &dev->descriptor);
+	if (r < 0) {
+		fprintf(stderr, "usb: error %d getting device descriptor: %s\n", r, __FUNCTION__);
+		return compat_err(r);
+	}
+
+	num_configurations = dev->descriptor.bNumConfigurations;
+	alloc_size = sizeof(struct usb_config_descriptor) * num_configurations;
+	dev->config = malloc(alloc_size);
+	if (!dev->config)
+		return -ENOMEM;
+	memset(dev->config, 0, alloc_size);
+
+	/* even though structures are identical, we can't just use libusb-1.0's
+	 * config descriptors because we have to store all configurations in
+	 * a single flat memory area (libusb-1.0 provides separate allocations).
+	 * we hand-copy libusb-1.0's descriptors into our own structures. */
+	for (i = 0; i < num_configurations; i++) {
+		struct libusb_config_descriptor *newlib_config;
+		r = libusb_get_config_descriptor(newlib_dev, i, &newlib_config);
+		if (r < 0) {
+			clear_device(dev);
+			free(dev->config);
+			return compat_err(r);
+		}
+		r = copy_config_descriptor(dev->config + i, newlib_config);
+		libusb_free_config_descriptor(newlib_config);
+		if (r < 0) {
+			clear_device(dev);
+			free(dev->config);
+			return r;
+		}
+	}
+
+	/* libusb doesn't implement this and it doesn't seem that important. If
+	 * someone asks for it, we can implement it in v1.1 or later. */
+	dev->num_children = 0;
+	dev->children = NULL;
+
+	libusb_ref_device(newlib_dev);
+	return 0;
+}
+
+int usb_find_devices(void)
+{
+	struct usb_bus *bus;
+	libusb_device **dev_list;
+	int dev_list_len;
+	int r;
+	int changes = 0;
+
+	/* libusb-1.0 initialization might have failed, but we can't indicate
+	 * this with libusb-0.1, so trap that situation here */
+	if (!ctx)
+		return 0;
+
+	dev_list_len = libusb_get_device_list(ctx, &dev_list);
+	if (dev_list_len < 0)
+		return compat_err(dev_list_len);
+
+	for (bus = usb_busses; bus; bus = bus->next) {
+		struct usb_device *new_devices = NULL;
+		struct usb_device *dev;
+
+		r = find_devices(dev_list, dev_list_len, bus, &new_devices);
+		if (r < 0) {
+			libusb_free_device_list(dev_list, 1);
+			return r;
+		}
+
+		/* walk through the devices we already know about, removing duplicates
+		 * from the new list. if we do not find it in the new list, the device
+		 * has been removed. */
+		dev = bus->devices;
+		while (dev) {
+			int found = 0;
+			struct usb_device *tdev = dev->next;
+			struct usb_device *ndev = new_devices;
+
+			while (ndev) {
+				if (ndev->devnum == dev->devnum) {
+					LIST_DEL(new_devices, ndev);
+					free(ndev);
+					found = 1;
+					break;
+				}
+				ndev = ndev->next;
+			}
+
+			if (!found) {
+				LIST_DEL(bus->devices, dev);
+				free_device(dev);
+				changes++;
+			}
+
+			dev = tdev;
+		}
+
+		/* anything left in new_devices is a new device */
+		dev = new_devices;
+		while (dev) {
+			struct usb_device *tdev = dev->next;
+			r = initialize_device(dev);	
+			if (r < 0) {
+				fprintf(stderr, "usb: couldn't initialize device %d.%d (error %d): %s\n",
+					dev->bus->location, dev->devnum, r, __FUNCTION__);
+				dev = tdev;
+				continue;
+			}
+			LIST_DEL(new_devices, dev);
+			LIST_ADD(bus->devices, dev);
+			changes++;
+			dev = tdev;
+		}
+	}
+
+	libusb_free_device_list(dev_list, 1);
+	return changes;
+}
+
+struct usb_bus *usb_get_busses(void)
+{
+	return usb_busses;
+}
+#endif
Index: psplinkusb/usbhostfs_pc/jetcompat.h
===================================================================
--- psplinkusb/usbhostfs_pc/jetcompat.h	(revision 0)
+++ psplinkusb/usbhostfs_pc/jetcompat.h	(revision 0)
@@ -0,0 +1,94 @@
+#ifndef __JETCOMPAT_H__
+#define __JETCOMPAT_H__
+#ifdef BUILD_LIBUSB10
+#include <libusb-1.0/libusb.h>
+
+/* Device descriptor */
+struct usb_device_descriptor {
+	u_int8_t  bLength;
+	u_int8_t  bDescriptorType;
+	u_int16_t bcdUSB;
+	u_int8_t  bDeviceClass;
+	u_int8_t  bDeviceSubClass;
+	u_int8_t  bDeviceProtocol;
+	u_int8_t  bMaxPacketSize0;
+	u_int16_t idVendor;
+	u_int16_t idProduct;
+	u_int16_t bcdDevice;
+	u_int8_t  iManufacturer;
+	u_int8_t  iProduct;
+	u_int8_t  iSerialNumber;
+	u_int8_t  bNumConfigurations;
+};
+
+/* Data types */
+struct usb_device;
+struct usb_bus;
+
+/*
+ * To maintain compatibility with applications already built with libusb,
+ * we must only add entries to the end of this structure. NEVER delete or
+ * move members and only change types if you really know what you're doing.
+ */
+struct usb_device {
+  struct usb_device *next, *prev;
+
+  char filename[PATH_MAX + 1];
+
+  struct usb_bus *bus;
+
+  struct usb_device_descriptor descriptor;
+  struct usb_config_descriptor *config;
+
+  void *dev;		/* Darwin support */
+
+  u_int8_t devnum;
+
+  unsigned char num_children;
+  struct usb_device **children;
+};
+
+struct usb_bus {
+  struct usb_bus *next, *prev;
+
+  char dirname[PATH_MAX + 1];
+
+  struct usb_device *devices;
+  u_int32_t location;
+
+  struct usb_device *root_dev;
+};
+
+struct usb_dev_handle;
+typedef struct usb_dev_handle usb_dev_handle;
+
+/* Variables */
+extern struct usb_bus *usb_busses;
+
+/* Function prototypes */
+usb_dev_handle *usb_open(struct usb_device *dev);
+int usb_close(usb_dev_handle *dev);
+
+int usb_bulk_write(usb_dev_handle *dev, int ep, char *bytes, int size, int timeout);
+int usb_bulk_read(usb_dev_handle *dev, int ep, char *bytes, int size, int timeout);
+
+void usb_init(void);
+int usb_find_busses(void);
+int usb_find_devices(void);
+int usb_reset(usb_dev_handle *dev);
+int usb_set_configuration(usb_dev_handle *dev, int configuration);
+int usb_claim_interface(usb_dev_handle *dev, int interface);
+int usb_release_interface(usb_dev_handle *dev, int interface);
+struct usb_bus *usb_get_busses(void);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#else
+#include <usb.h>
+#endif
+#endif /* __JETCOMPAT_H__ */
\ No newline at end of file
Index: psplinkusb/usbhostfs_pc/Makefile
===================================================================
--- psplinkusb/usbhostfs_pc/Makefile	(revision 2494)
+++ psplinkusb/usbhostfs_pc/Makefile	(working copy)
@@ -1,11 +1,18 @@
 OUTPUT=usbhostfs_pc
-OBJS=main.o
-LIBS=-lusb -lpthread
+OBJS=jetcompat.o main.o
+LIBS=-lpthread
 CFLAGS=-Wall -ggdb -I../usbhostfs -DPC_SIDE -D_FILE_OFFSET_BITS=64 -I. -O2
 LDFLAGS=-L.
 
 PREFIX=$(shell psp-config --pspdev-path 2> /dev/null)
 
+ifdef BUILD_LIBUSB10
+CFLAGS += -DBUILD_LIBUSB10
+LIBS +=-lusb-1.0
+else
+LIBS +=-lusb
+endif
+
 ifdef BUILD_BIGENDIAN
 CFLAGS += -DBUILD_BIGENDIAN
 endif
@@ -19,6 +26,17 @@
 LIBS += -lreadline -lcurses
 endif
 
+ifdef BUILD_MACOSX
+CFLAGS +=-I/opt/local/include
+LDFLAGS += -L/opt/local/lib
+endif
+
+ifdef BUILD_SOLARIS
+CC=cc
+CXX=CC
+LIBS +=-lnsl -lsocket
+endif
+
 ifdef BUILD_WIN32
 CFLAGS  += -I../windows/lib -Wno-format
 LDFLAGS += -L../windows/lib
